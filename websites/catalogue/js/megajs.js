(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
            typeof define === 'function' && define.amd ? define(factory) :
            (global.mega = factory());
}(this, (function () { 'use strict';

            var global$1 = (typeof global !== "undefined" ? global :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var inited = false;
            function init () {
              inited = true;
              var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
              }

              revLookup['-'.charCodeAt(0)] = 62;
              revLookup['_'.charCodeAt(0)] = 63;
            }

            function toByteArray (b64) {
              if (!inited) {
                init();
              }
              var i, j, l, tmp, placeHolders, arr;
              var len = b64.length;

              if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr(len * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? len - 4 : len;

              var L = 0;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
              } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              return arr
            }

            function tripletToBase64 (num) {
              return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
            }

            function encodeChunk (uint8, start, end) {
              var tmp;
              var output = [];
              for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(tripletToBase64(tmp));
              }
              return output.join('')
            }

            function fromByteArray (uint8) {
              if (!inited) {
                init();
              }
              var tmp;
              var len = uint8.length;
              var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
              var output = '';
              var parts = [];
              var maxChunkLength = 16383; // must be multiple of 3

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += lookup[tmp >> 2];
                output += lookup[(tmp << 4) & 0x3F];
                output += '==';
              } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += lookup[tmp >> 10];
                output += lookup[(tmp >> 4) & 0x3F];
                output += lookup[(tmp << 2) & 0x3F];
                output += '=';
              }

              parts.push(output);

              return parts.join('')
            }

            function read (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? (nBytes - 1) : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];

              i += d;

              e = s & ((1 << (-nBits)) - 1);
              s >>= (-nBits);
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              m = e & ((1 << (-nBits)) - 1);
              e >>= (-nBits);
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }

            function write (buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
              var i = isLE ? 0 : (nBytes - 1);
              var d = isLE ? 1 : -1;
              var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

              value = Math.abs(value);

              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }

                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }

              for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

              e = (e << mLen) | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

              buffer[offset + i - d] |= s * 128;
            }

            var toString = {}.toString;

            var isArray = Array.isArray || function (arr) {
              return toString.call(arr) == '[object Array]';
            };

            var INSPECT_MAX_BYTES = 50;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
              ? global$1.TYPED_ARRAY_SUPPORT
              : true;

            function kMaxLength () {
              return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
            }

            function createBuffer (that, length) {
              if (kMaxLength() < length) {
                throw new RangeError('Invalid typed array length')
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                if (that === null) {
                  that = new Buffer(length);
                }
                that.length = length;
              }

              return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer (arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length)
              }

              // Common case.
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  )
                }
                return allocUnsafe(this, arg)
              }
              return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192; // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
              arr.__proto__ = Buffer.prototype;
              return arr
            };

            function from (that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
              }

              if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value, encodingOrOffset, length)
              }

              if (typeof value === 'string') {
                return fromString(that, value, encodingOrOffset)
              }

              return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length)
            };

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
            }

            function assertSize (size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number')
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
              }
            }

            function alloc (that, size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(that, size)
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill)
              }
              return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(null, size, fill, encoding)
            };

            function allocUnsafe (that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(null, size)
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(null, size)
            };

            function fromString (that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding')
              }

              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);

              var actual = that.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                that = that.slice(0, actual);
              }

              return that
            }

            function fromArrayLike (that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that
            }

            function fromArrayBuffer (that, array, byteOffset, length) {
              array.byteLength; // this throws if `array` is not a valid ArrayBuffer

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('\'offset\' is out of bounds')
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('\'length\' is out of bounds')
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromArrayLike(that, array);
              }
              return that
            }

            function fromObject (that, obj) {
              if (internalIsBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);

                if (that.length === 0) {
                  return that
                }

                obj.copy(that, 0, 0, len);
                return that
              }

              if (obj) {
                if ((typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                  if (typeof obj.length !== 'number' || isnan(obj.length)) {
                    return createBuffer(that, 0)
                  }
                  return fromArrayLike(that, obj)
                }

                if (obj.type === 'Buffer' && isArray(obj.data)) {
                  return fromArrayLike(that, obj.data)
                }
              }

              throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked (length) {
              // Note: cannot use `length < kMaxLength()` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                     'size: 0x' + kMaxLength().toString(16) + ' bytes')
              }
              return length | 0
            }
            Buffer.isBuffer = isBuffer;
            function internalIsBuffer (b) {
              return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare (a, b) {
              if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
              }

              if (a === b) return 0

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            Buffer.isEncoding = function isEncoding (encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true
                default:
                  return false
              }
            };

            Buffer.concat = function concat (list, length) {
              if (!isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }

              if (list.length === 0) {
                return Buffer.alloc(0)
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!internalIsBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer
            };

            function byteLength (string, encoding) {
              if (internalIsBuffer(string)) {
                return string.length
              }
              if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                  (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }

              var len = string.length;
              if (len === 0) return 0

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes(string).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2
                  case 'hex':
                    return len >>> 1
                  case 'base64':
                    return base64ToBytes(string).length
                  default:
                    if (loweredCase) return utf8ToBytes(string).length // assume utf8
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString (encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return ''
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return ''
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return ''
              }

              if (!encoding) encoding = 'utf8';

              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice(this, start, end)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice(this, start, end)

                  case 'ascii':
                    return asciiSlice(this, start, end)

                  case 'latin1':
                  case 'binary':
                    return latin1Slice(this, start, end)

                  case 'base64':
                    return base64Slice(this, start, end)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice(this, start, end)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true;

            function swap (b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16 () {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this
            };

            Buffer.prototype.swap32 = function swap32 () {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this
            };

            Buffer.prototype.swap64 = function swap64 () {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this
            };

            Buffer.prototype.toString = function toString () {
              var length = this.length | 0;
              if (length === 0) return ''
              if (arguments.length === 0) return utf8Slice(this, 0, length)
              return slowToString.apply(this, arguments)
            };

            Buffer.prototype.equals = function equals (b) {
              if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
              if (this === b) return true
              return Buffer.compare(this, b) === 0
            };

            Buffer.prototype.inspect = function inspect () {
              var str = '';
              var max = INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>'
            };

            Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
              if (!internalIsBuffer(target)) {
                throw new TypeError('Argument must be a Buffer')
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0
              }
              if (thisStart >= thisEnd) {
                return -1
              }
              if (start >= end) {
                return 1
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1

              // Normalize byteOffset
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset;  // Coerce to Number.
              if (isNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1);
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1
              }

              // Normalize val
              if (typeof val === 'string') {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (internalIsBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
              } else if (typeof val === 'number') {
                val = val & 0xFF; // Search for a byte value [0-255]
                if (Buffer.TYPED_ARRAY_SUPPORT &&
                    typeof Uint8Array.prototype.indexOf === 'function') {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                  }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
              }

              throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                    encoding === 'utf16le' || encoding === 'utf-16le') {
                  if (arr.length < 2 || val.length < 2) {
                    return -1
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read$$1 (buf, i) {
                if (indexSize === 1) {
                  return buf[i]
                } else {
                  return buf.readUInt16BE(i * indexSize)
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read$$1(arr, i + j) !== read$$1(val, j)) {
                      found = false;
                      break
                    }
                  }
                  if (found) return i
                }
              }

              return -1
            }

            Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1
            };

            Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            };

            function hexWrite (buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              // must be an even number of digits
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i
                buf[offset + i] = parsed;
              }
              return i
            }

            function utf8Write (buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite (buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write (buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length)
            }

            function base64Write (buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write (buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              // legacy write(string, encoding, offset, length) - remove in v0.13
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
              }

              if (!encoding) encoding = 'utf8';

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite(this, string, offset, length)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Write(this, string, offset, length)

                  case 'ascii':
                    return asciiWrite(this, string, offset, length)

                  case 'latin1':
                  case 'binary':
                    return latin1Write(this, string, offset, length)

                  case 'base64':
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write(this, string, offset, length)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON () {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              }
            };

            function base64Slice (buf, start, end) {
              if (start === 0 && end === buf.length) {
                return fromByteArray(buf)
              } else {
                return fromByteArray(buf.slice(start, end))
              }
            }

            function utf8Slice (buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                  : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                  : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xFFFD;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xFFFF) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                  codePoint = 0xDC00 | codePoint & 0x3FF;
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray (codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res
            }

            function asciiSlice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F);
              }
              return ret
            }

            function latin1Slice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret
            }

            function hexSlice (buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out
            }

            function utf16leSlice (buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res
            }

            Buffer.prototype.slice = function slice (start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset (offset, ext, length) {
              if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
              if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val
            };

            Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val
            };

            Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset]
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8)
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1]
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return ((this[offset]) |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  (this[offset + 3] * 0x1000000)
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            };

            Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return (this[offset])
              return ((0xff - this[offset] + 1) * -1)
            };

            Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
            };

            Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
            };

            Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, true, 23, 4)
            };

            Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, false, 23, 4)
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, true, 52, 8)
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, false, 52, 8)
            };

            function checkInt (buf, value, offset, ext, max, min) {
              if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = (value & 0xff);
              return offset + 1
            };

            function objectWriteUInt16 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  (littleEndian ? i : 1 - i) * 8;
              }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            function objectWriteUInt32 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
              }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = (value & 0xff);
              return offset + 1
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            function checkIEEE754 (buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
              if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
              }
              write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert)
            };

            function writeDouble (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
              }
              write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert)
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy (target, targetStart, start, end) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0
              if (target.length === 0 || this.length === 0) return 0

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
              }
              if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
              if (end < 0) throw new RangeError('sourceEnd out of bounds')

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill (val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
              }

              if (end <= start) {
                return this
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = internalIsBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean (str) {
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = stringtrim(str).replace(INVALID_BASE64_RE, '');
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return ''
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str
            }

            function stringtrim (str) {
              if (str.trim) return str.trim()
              return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex (n) {
              if (n < 16) return '0' + n.toString(16)
              return n.toString(16)
            }

            function utf8ToBytes (string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xDBFF) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue
                  }

                  // 2 leads in a row
                  if (codePoint < 0xDC00) {
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    leadSurrogate = codePoint;
                    continue
                  }

                  // valid surrogate pair
                  codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break
                  bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break
                  bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break
                  bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else {
                  throw new Error('Invalid code point')
                }
              }

              return bytes
            }

            function asciiToBytes (str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF);
              }
              return byteArray
            }

            function utf16leToBytes (str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray
            }


            function base64ToBytes (str) {
              return toByteArray(base64clean(str))
            }

            function blitBuffer (src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i];
              }
              return i
            }

            function isnan (val) {
              return val !== val // eslint-disable-line no-self-compare
            }


            // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            function isBuffer(obj) {
              return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
            }

            function isFastBuffer (obj) {
              return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer (obj) {
              return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
            }

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout = defaultSetTimout;
            var cachedClearTimeout = defaultClearTimeout;
            if (typeof global$1.setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            }
            if (typeof global$1.clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            }

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }



            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while(len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            function nextTick(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            }
            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title = 'browser';
            var platform = 'browser';
            var browser = true;
            var env = {};
            var argv = [];
            var version = ''; // empty string to avoid regexp issues
            var versions = {};
            var release = {};
            var config = {};

            function noop() {}

            var on = noop;
            var addListener = noop;
            var once = noop;
            var off = noop;
            var removeListener = noop;
            var removeAllListeners = noop;
            var emit = noop;

            function binding(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd () { return '/' }
            function chdir (dir) {
                throw new Error('process.chdir is not supported');
            }function umask() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance = global$1.performance || {};
            var performanceNow =
              performance.now        ||
              performance.mozNow     ||
              performance.msNow      ||
              performance.oNow       ||
              performance.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime(previousTimestamp){
              var clocktime = performanceNow.call(performance)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime = new Date();
            function uptime() {
              var currentTime = new Date();
              var dif = currentTime - startTime;
              return dif / 1000;
            }

            var process = {
              nextTick: nextTick,
              title: title,
              browser: browser,
              env: env,
              argv: argv,
              version: version,
              versions: versions,
              on: on,
              addListener: addListener,
              once: once,
              off: off,
              removeListener: removeListener,
              removeAllListeners: removeAllListeners,
              emit: emit,
              binding: binding,
              cwd: cwd,
              chdir: chdir,
              umask: umask,
              hrtime: hrtime,
              platform: platform,
              release: release,
              config: config,
              uptime: uptime
            };

            var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var domain;

            // This constructor is used to store event handlers. Instantiating this is
            // faster than explicitly calling `Object.create(null)` to get a "clean" empty
            // object (tested with v8 v4.9).
            function EventHandlers() {}
            EventHandlers.prototype = Object.create(null);

            function EventEmitter() {
              EventEmitter.init.call(this);
            }

            // nodejs oddity
            // require('events') === require('events').EventEmitter
            EventEmitter.EventEmitter = EventEmitter;

            EventEmitter.usingDomains = false;

            EventEmitter.prototype.domain = undefined;
            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._maxListeners = undefined;

            // By default EventEmitters will print a warning if more than 10 listeners are
            // added to it. This is a useful default which helps finding memory leaks.
            EventEmitter.defaultMaxListeners = 10;

            EventEmitter.init = function() {
              this.domain = null;
              if (EventEmitter.usingDomains) {
                // if there is an active domain, then attach to it.
                if (domain.active && !(this instanceof domain.Domain)) {
                  this.domain = domain.active;
                }
              }

              if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
                this._events = new EventHandlers();
                this._eventsCount = 0;
              }

              this._maxListeners = this._maxListeners || undefined;
            };

            // Obviously not all Emitters should be limited to 10. This function allows
            // that to be increased. Set to zero for unlimited.
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== 'number' || n < 0 || isNaN(n))
                throw new TypeError('"n" argument must be a positive number');
              this._maxListeners = n;
              return this;
            };

            function $getMaxListeners(that) {
              if (that._maxListeners === undefined)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }

            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return $getMaxListeners(this);
            };

            // These standalone emit* functions are used to optimize calling of event
            // handlers for fast cases because emit() itself often has a variable number of
            // arguments and can be deoptimized because of that. These functions always have
            // the same number of arguments and thus do not get deoptimized, so the code
            // inside them can execute faster.
            function emitNone(handler, isFn, self) {
              if (isFn)
                handler.call(self);
              else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  listeners[i].call(self);
              }
            }
            function emitOne(handler, isFn, self, arg1) {
              if (isFn)
                handler.call(self, arg1);
              else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  listeners[i].call(self, arg1);
              }
            }
            function emitTwo(handler, isFn, self, arg1, arg2) {
              if (isFn)
                handler.call(self, arg1, arg2);
              else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  listeners[i].call(self, arg1, arg2);
              }
            }
            function emitThree(handler, isFn, self, arg1, arg2, arg3) {
              if (isFn)
                handler.call(self, arg1, arg2, arg3);
              else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  listeners[i].call(self, arg1, arg2, arg3);
              }
            }

            function emitMany(handler, isFn, self, args) {
              if (isFn)
                handler.apply(self, args);
              else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  listeners[i].apply(self, args);
              }
            }

            EventEmitter.prototype.emit = function emit(type) {
              var er, handler, len, args, i, events, domain;
              var needDomainExit = false;
              var doError = (type === 'error');

              events = this._events;
              if (events)
                doError = (doError && events.error == null);
              else if (!doError)
                return false;

              domain = this.domain;

              // If there is no 'error' event listener then throw.
              if (doError) {
                er = arguments[1];
                if (domain) {
                  if (!er)
                    er = new Error('Uncaught, unspecified "error" event');
                  er.domainEmitter = this;
                  er.domain = domain;
                  er.domainThrown = false;
                  domain.emit('error', er);
                } else if (er instanceof Error) {
                  throw er; // Unhandled 'error' event
                } else {
                  // At least give some kind of context to the user
                  var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                  err.context = er;
                  throw err;
                }
                return false;
              }

              handler = events[type];

              if (!handler)
                return false;

              var isFn = typeof handler === 'function';
              len = arguments.length;
              switch (len) {
                // fast cases
                case 1:
                  emitNone(handler, isFn, this);
                  break;
                case 2:
                  emitOne(handler, isFn, this, arguments[1]);
                  break;
                case 3:
                  emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                  break;
                case 4:
                  emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                  break;
                // slower
                default:
                  args = new Array(len - 1);
                  for (i = 1; i < len; i++)
                    args[i - 1] = arguments[i];
                  emitMany(handler, isFn, this, args);
              }

              if (needDomainExit)
                domain.exit();

              return true;
            };

            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;

              if (typeof listener !== 'function')
                throw new TypeError('"listener" argument must be a function');

              events = target._events;
              if (!events) {
                events = target._events = new EventHandlers();
                target._eventsCount = 0;
              } else {
                // To avoid recursion in the case that type === "newListener"! Before
                // adding it to the listeners, first emit "newListener".
                if (events.newListener) {
                  target.emit('newListener', type,
                              listener.listener ? listener.listener : listener);

                  // Re-assign `events` because a newListener handler could have caused the
                  // this._events to be assigned to a new object
                  events = target._events;
                }
                existing = events[type];
              }

              if (!existing) {
                // Optimize the case of one listener. Don't need the extra array object.
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === 'function') {
                  // Adding the second element, need to change to array.
                  existing = events[type] = prepend ? [listener, existing] :
                                                      [existing, listener];
                } else {
                  // If we've already got an array, just append.
                  if (prepend) {
                    existing.unshift(listener);
                  } else {
                    existing.push(listener);
                  }
                }

                // Check for listener leak
                if (!existing.warned) {
                  m = $getMaxListeners(target);
                  if (m && m > 0 && existing.length > m) {
                    existing.warned = true;
                    var w = new Error('Possible EventEmitter memory leak detected. ' +
                                        existing.length + ' ' + type + ' listeners added. ' +
                                        'Use emitter.setMaxListeners() to increase limit');
                    w.name = 'MaxListenersExceededWarning';
                    w.emitter = target;
                    w.type = type;
                    w.count = existing.length;
                    emitWarning(w);
                  }
                }
              }

              return target;
            }
            function emitWarning(e) {
              typeof console.warn === 'function' ? console.warn(e) : console.log(e);
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };

            EventEmitter.prototype.on = EventEmitter.prototype.addListener;

            EventEmitter.prototype.prependListener =
                function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };

            function _onceWrap(target, type, listener) {
              var fired = false;
              function g() {
                target.removeListener(type, g);
                if (!fired) {
                  fired = true;
                  listener.apply(target, arguments);
                }
              }
              g.listener = listener;
              return g;
            }

            EventEmitter.prototype.once = function once(type, listener) {
              if (typeof listener !== 'function')
                throw new TypeError('"listener" argument must be a function');
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };

            EventEmitter.prototype.prependOnceListener =
                function prependOnceListener(type, listener) {
                  if (typeof listener !== 'function')
                    throw new TypeError('"listener" argument must be a function');
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };

            // emits a 'removeListener' event iff the listener was removed
            EventEmitter.prototype.removeListener =
                function removeListener(type, listener) {
                  var list, events, position, i, originalListener;

                  if (typeof listener !== 'function')
                    throw new TypeError('"listener" argument must be a function');

                  events = this._events;
                  if (!events)
                    return this;

                  list = events[type];
                  if (!list)
                    return this;

                  if (list === listener || (list.listener && list.listener === listener)) {
                    if (--this._eventsCount === 0)
                      this._events = new EventHandlers();
                    else {
                      delete events[type];
                      if (events.removeListener)
                        this.emit('removeListener', type, list.listener || listener);
                    }
                  } else if (typeof list !== 'function') {
                    position = -1;

                    for (i = list.length; i-- > 0;) {
                      if (list[i] === listener ||
                          (list[i].listener && list[i].listener === listener)) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }

                    if (position < 0)
                      return this;

                    if (list.length === 1) {
                      list[0] = undefined;
                      if (--this._eventsCount === 0) {
                        this._events = new EventHandlers();
                        return this;
                      } else {
                        delete events[type];
                      }
                    } else {
                      spliceOne(list, position);
                    }

                    if (events.removeListener)
                      this.emit('removeListener', type, originalListener || listener);
                  }

                  return this;
                };

            EventEmitter.prototype.removeAllListeners =
                function removeAllListeners(type) {
                  var listeners, events;

                  events = this._events;
                  if (!events)
                    return this;

                  // not listening for removeListener, no need to emit
                  if (!events.removeListener) {
                    if (arguments.length === 0) {
                      this._events = new EventHandlers();
                      this._eventsCount = 0;
                    } else if (events[type]) {
                      if (--this._eventsCount === 0)
                        this._events = new EventHandlers();
                      else
                        delete events[type];
                    }
                    return this;
                  }

                  // emit removeListener for all listeners on all events
                  if (arguments.length === 0) {
                    var keys = Object.keys(events);
                    for (var i = 0, key; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === 'removeListener') continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners('removeListener');
                    this._events = new EventHandlers();
                    this._eventsCount = 0;
                    return this;
                  }

                  listeners = events[type];

                  if (typeof listeners === 'function') {
                    this.removeListener(type, listeners);
                  } else if (listeners) {
                    // LIFO order
                    do {
                      this.removeListener(type, listeners[listeners.length - 1]);
                    } while (listeners[0]);
                  }

                  return this;
                };

            EventEmitter.prototype.listeners = function listeners(type) {
              var evlistener;
              var ret;
              var events = this._events;

              if (!events)
                ret = [];
              else {
                evlistener = events[type];
                if (!evlistener)
                  ret = [];
                else if (typeof evlistener === 'function')
                  ret = [evlistener.listener || evlistener];
                else
                  ret = unwrapListeners(evlistener);
              }

              return ret;
            };

            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === 'function') {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };

            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;

              if (events) {
                var evlistener = events[type];

                if (typeof evlistener === 'function') {
                  return 1;
                } else if (evlistener) {
                  return evlistener.length;
                }
              }

              return 0;
            }

            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
            };

            // About 1.5x faster than the two-arg version of Array#splice().
            function spliceOne(list, index) {
              for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
                list[i] = list[k];
              list.pop();
            }

            function arrayClone(arr, i) {
              var copy = new Array(i);
              while (i--)
                copy[i] = arr[i];
              return copy;
            }

            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }

            var inherits;
            if (typeof Object.create === 'function'){
              inherits = function inherits(ctor, superCtor) {
                // implementation from standard node.js 'util' module
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              };
            } else {
              inherits = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function () {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              };
            }
            var inherits$1 = inherits;

            var formatRegExp = /%[sdj%]/g;
            function format(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                  case '%s': return String(args[i++]);
                  case '%d': return Number(args[i++]);
                  case '%j':
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return '[Circular]';
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += ' ' + x;
                } else {
                  str += ' ' + inspect(x);
                }
              }
              return str;
            }

            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            function deprecate(fn, msg) {
              // Allow for deprecating things in the process of starting up.
              if (isUndefined(global$1.process)) {
                return function() {
                  return deprecate(fn, msg).apply(this, arguments);
                };
              }

              if (process.noDeprecation === true) {
                return fn;
              }

              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            }

            var debugs = {};
            var debugEnviron;
            function debuglog(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                  var pid = 0;
                  debugs[set] = function() {
                    var msg = format.apply(null, arguments);
                    console.error('%s %d: %s', set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {};
                }
              }
              return debugs[set];
            }

            /**
             * Echos the value of a value. Trys to print the value out
             * in the best way possible given the different types.
             *
             * @param {Object} obj The object to print out.
             * @param {Object} opts Optional options object that alters the output.
             */
            /* legacy: obj, showHidden, depth, colors*/
            function inspect(obj, opts) {
              // default options
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              // legacy...
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
              } else if (opts) {
                // got an "options" object
                _extend(ctx, opts);
              }
              // set default options
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }

            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              'bold' : [1, 22],
              'italic' : [3, 23],
              'underline' : [4, 24],
              'inverse' : [7, 27],
              'white' : [37, 39],
              'grey' : [90, 39],
              'black' : [30, 39],
              'blue' : [34, 39],
              'cyan' : [36, 39],
              'green' : [32, 39],
              'magenta' : [35, 39],
              'red' : [31, 39],
              'yellow' : [33, 39]
            };

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              'special': 'cyan',
              'number': 'yellow',
              'boolean': 'yellow',
              'undefined': 'grey',
              'null': 'bold',
              'string': 'green',
              'date': 'magenta',
              // "name": intentionally not styling
              'regexp': 'red'
            };


            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                       '\u001b[' + inspect.colors[style][1] + 'm';
              } else {
                return str;
              }
            }


            function stylizeNoColor(str, styleType) {
              return str;
            }


            function arrayToHash(array) {
              var hash = {};

              array.forEach(function(val, idx) {
                hash[val] = true;
              });

              return hash;
            }


            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (ctx.customInspect &&
                  value &&
                  isFunction(value.inspect) &&
                  // Filter out the util module, it's inspect function is special
                  value.inspect !== inspect &&
                  // Also filter out any prototype objects using the circular check.
                  !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }

              // Look up the keys of the object.
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              // IE doesn't make error fields non-enumerable
              // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
              if (isError(value)
                  && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ': ' + value.name : '';
                  return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = '', array = false, braces = ['{', '}'];

              // Make Array say that they are Array
              if (isArray$1(value)) {
                array = true;
                braces = ['[', ']'];
              }

              // Make functions say that they are functions
              if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = ' ' + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                  return ctx.stylize('[Object]', 'special');
                }
              }

              ctx.seen.push(value);

              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }

              ctx.seen.pop();

              return reduceToSingleString(output, base, braces);
            }


            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
              if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                         .replace(/'/g, "\\'")
                                                         .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
              }
              if (isNumber(value))
                return ctx.stylize('' + value, 'number');
              if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
              // For some reason typeof null is "object", so special case here.
              if (isNull(value))
                return ctx.stylize('null', 'null');
            }


            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']';
            }


            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                      String(i), true));
                } else {
                  output.push('');
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                      key, true));
                }
              });
              return output;
            }


            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                  str = ctx.stylize('[Getter]', 'special');
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str.split('\n').map(function(line) {
                        return '  ' + line;
                      }).join('\n').substr(2);
                    } else {
                      str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                      }).join('\n');
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special');
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, 'name');
                } else {
                  name = name.replace(/'/g, "\\'")
                             .replace(/\\"/g, '"')
                             .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, 'string');
                }
              }

              return name + ': ' + str;
            }


            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf('\n') >= 0) ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);

              if (length > 60) {
                return braces[0] +
                       (base === '' ? '' : base + '\n ') +
                       ' ' +
                       output.join(',\n  ') +
                       ' ' +
                       braces[1];
              }

              return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }


            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray$1(ar) {
              return Array.isArray(ar);
            }

            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }

            function isNull(arg) {
              return arg === null;
            }

            function isNullOrUndefined(arg) {
              return arg == null;
            }

            function isNumber(arg) {
              return typeof arg === 'number';
            }

            function isString(arg) {
              return typeof arg === 'string';
            }

            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }

            function isUndefined(arg) {
              return arg === void 0;
            }

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]';
            }

            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }

            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]';
            }

            function isError(e) {
              return isObject(e) &&
                  (objectToString(e) === '[object Error]' || e instanceof Error);
            }

            function isFunction(arg) {
              return typeof arg === 'function';
            }

            function isPrimitive(arg) {
              return arg === null ||
                     typeof arg === 'boolean' ||
                     typeof arg === 'number' ||
                     typeof arg === 'string' ||
                     typeof arg === 'symbol' ||  // ES6 symbol
                     typeof arg === 'undefined';
            }

            function isBuffer$1(maybeBuf) {
              return isBuffer(maybeBuf);
            }

            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }


            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }


            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                          'Oct', 'Nov', 'Dec'];

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()),
                          pad(d.getMinutes()),
                          pad(d.getSeconds())].join(':');
              return [d.getDate(), months[d.getMonth()], time].join(' ');
            }


            // log is just a thin wrapper to console.log that prepends a timestamp
            function log() {
              console.log('%s - %s', timestamp(), format.apply(null, arguments));
            }

            function _extend(origin, add) {
              // Don't do anything if add isn't an object
              if (!add || !isObject(add)) return origin;

              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            }
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }

            var util = {
              inherits: inherits$1,
              _extend: _extend,
              log: log,
              isBuffer: isBuffer$1,
              isPrimitive: isPrimitive,
              isFunction: isFunction,
              isError: isError,
              isDate: isDate,
              isObject: isObject,
              isRegExp: isRegExp,
              isUndefined: isUndefined,
              isSymbol: isSymbol,
              isString: isString,
              isNumber: isNumber,
              isNullOrUndefined: isNullOrUndefined,
              isNull: isNull,
              isBoolean: isBoolean,
              isArray: isArray$1,
              inspect: inspect,
              deprecate: deprecate,
              format: format,
              debuglog: debuglog
            }

            var util$1 = /*#__PURE__*/Object.freeze({
                        format: format,
                        deprecate: deprecate,
                        debuglog: debuglog,
                        inspect: inspect,
                        isArray: isArray$1,
                        isBoolean: isBoolean,
                        isNull: isNull,
                        isNullOrUndefined: isNullOrUndefined,
                        isNumber: isNumber,
                        isString: isString,
                        isSymbol: isSymbol,
                        isUndefined: isUndefined,
                        isRegExp: isRegExp,
                        isObject: isObject,
                        isDate: isDate,
                        isError: isError,
                        isFunction: isFunction,
                        isPrimitive: isPrimitive,
                        isBuffer: isBuffer$1,
                        log: log,
                        inherits: inherits$1,
                        _extend: _extend,
                        default: util
            });

            function BufferList() {
              this.head = null;
              this.tail = null;
              this.length = 0;
            }

            BufferList.prototype.push = function (v) {
              var entry = { data: v, next: null };
              if (this.length > 0) this.tail.next = entry;else this.head = entry;
              this.tail = entry;
              ++this.length;
            };

            BufferList.prototype.unshift = function (v) {
              var entry = { data: v, next: this.head };
              if (this.length === 0) this.tail = entry;
              this.head = entry;
              ++this.length;
            };

            BufferList.prototype.shift = function () {
              if (this.length === 0) return;
              var ret = this.head.data;
              if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
              --this.length;
              return ret;
            };

            BufferList.prototype.clear = function () {
              this.head = this.tail = null;
              this.length = 0;
            };

            BufferList.prototype.join = function (s) {
              if (this.length === 0) return '';
              var p = this.head;
              var ret = '' + p.data;
              while (p = p.next) {
                ret += s + p.data;
              }return ret;
            };

            BufferList.prototype.concat = function (n) {
              if (this.length === 0) return Buffer.alloc(0);
              if (this.length === 1) return this.head.data;
              var ret = Buffer.allocUnsafe(n >>> 0);
              var p = this.head;
              var i = 0;
              while (p) {
                p.data.copy(ret, i);
                i += p.data.length;
                p = p.next;
              }
              return ret;
            };

            // Copyright Joyent, Inc. and other Node contributors.
            var isBufferEncoding = Buffer.isEncoding
              || function(encoding) {
                   switch (encoding && encoding.toLowerCase()) {
                     case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
                     default: return false;
                   }
                 };


            function assertEncoding(encoding) {
              if (encoding && !isBufferEncoding(encoding)) {
                throw new Error('Unknown encoding: ' + encoding);
              }
            }

            // StringDecoder provides an interface for efficiently splitting a series of
            // buffers into a series of JS strings without breaking apart multi-byte
            // characters. CESU-8 is handled as part of the UTF-8 encoding.
            //
            // @TODO Handling all encodings inside a single object makes it very difficult
            // to reason about this code, so it should be split up in the future.
            // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
            // points as used by CESU-8.
            function StringDecoder(encoding) {
              this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
              assertEncoding(encoding);
              switch (this.encoding) {
                case 'utf8':
                  // CESU-8 represents each of Surrogate Pair by 3-bytes
                  this.surrogateSize = 3;
                  break;
                case 'ucs2':
                case 'utf16le':
                  // UTF-16 represents each of Surrogate Pair by 2-bytes
                  this.surrogateSize = 2;
                  this.detectIncompleteChar = utf16DetectIncompleteChar;
                  break;
                case 'base64':
                  // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                  this.surrogateSize = 3;
                  this.detectIncompleteChar = base64DetectIncompleteChar;
                  break;
                default:
                  this.write = passThroughWrite;
                  return;
              }

              // Enough space to store all bytes of a single character. UTF-8 needs 4
              // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
              this.charBuffer = new Buffer(6);
              // Number of bytes received for the current incomplete multi-byte character.
              this.charReceived = 0;
              // Number of bytes expected for the current incomplete multi-byte character.
              this.charLength = 0;
            }

            // write decodes the given buffer and returns it as JS string that is
            // guaranteed to not contain any partial multi-byte characters. Any partial
            // character found at the end of the buffer is buffered up, and will be
            // returned when calling write again with the remaining bytes.
            //
            // Note: Converting a Buffer containing an orphan surrogate to a String
            // currently works, but converting a String to a Buffer (via `new Buffer`, or
            // Buffer#write) will replace incomplete surrogates with the unicode
            // replacement character. See https://codereview.chromium.org/121173009/ .
            StringDecoder.prototype.write = function(buffer) {
              var charStr = '';
              // if our last write ended with an incomplete multibyte character
              while (this.charLength) {
                // determine how many remaining bytes this buffer has to offer for this char
                var available = (buffer.length >= this.charLength - this.charReceived) ?
                    this.charLength - this.charReceived :
                    buffer.length;

                // add the new bytes to the char buffer
                buffer.copy(this.charBuffer, this.charReceived, 0, available);
                this.charReceived += available;

                if (this.charReceived < this.charLength) {
                  // still not enough chars in this buffer? wait for more ...
                  return '';
                }

                // remove bytes belonging to the current character from the buffer
                buffer = buffer.slice(available, buffer.length);

                // get the character that was split
                charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

                // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                var charCode = charStr.charCodeAt(charStr.length - 1);
                if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                  this.charLength += this.surrogateSize;
                  charStr = '';
                  continue;
                }
                this.charReceived = this.charLength = 0;

                // if there are no more bytes in this buffer, just emit our char
                if (buffer.length === 0) {
                  return charStr;
                }
                break;
              }

              // determine and set charLength / charReceived
              this.detectIncompleteChar(buffer);

              var end = buffer.length;
              if (this.charLength) {
                // buffer the incomplete character bytes we got
                buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                end -= this.charReceived;
              }

              charStr += buffer.toString(this.encoding, 0, end);

              var end = charStr.length - 1;
              var charCode = charStr.charCodeAt(end);
              // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
              if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                var size = this.surrogateSize;
                this.charLength += size;
                this.charReceived += size;
                this.charBuffer.copy(this.charBuffer, size, 0, size);
                buffer.copy(this.charBuffer, 0, 0, size);
                return charStr.substring(0, end);
              }

              // or just emit the charStr
              return charStr;
            };

            // detectIncompleteChar determines if there is an incomplete UTF-8 character at
            // the end of the given buffer. If so, it sets this.charLength to the byte
            // length that character, and sets this.charReceived to the number of bytes
            // that are available for this character.
            StringDecoder.prototype.detectIncompleteChar = function(buffer) {
              // determine how many bytes we have to check at the end of this buffer
              var i = (buffer.length >= 3) ? 3 : buffer.length;

              // Figure out if one of the last i bytes of our buffer announces an
              // incomplete char.
              for (; i > 0; i--) {
                var c = buffer[buffer.length - i];

                // See http://en.wikipedia.org/wiki/UTF-8#Description

                // 110XXXXX
                if (i == 1 && c >> 5 == 0x06) {
                  this.charLength = 2;
                  break;
                }

                // 1110XXXX
                if (i <= 2 && c >> 4 == 0x0E) {
                  this.charLength = 3;
                  break;
                }

                // 11110XXX
                if (i <= 3 && c >> 3 == 0x1E) {
                  this.charLength = 4;
                  break;
                }
              }
              this.charReceived = i;
            };

            StringDecoder.prototype.end = function(buffer) {
              var res = '';
              if (buffer && buffer.length)
                res = this.write(buffer);

              if (this.charReceived) {
                var cr = this.charReceived;
                var buf = this.charBuffer;
                var enc = this.encoding;
                res += buf.slice(0, cr).toString(enc);
              }

              return res;
            };

            function passThroughWrite(buffer) {
              return buffer.toString(this.encoding);
            }

            function utf16DetectIncompleteChar(buffer) {
              this.charReceived = buffer.length % 2;
              this.charLength = this.charReceived ? 2 : 0;
            }

            function base64DetectIncompleteChar(buffer) {
              this.charReceived = buffer.length % 3;
              this.charLength = this.charReceived ? 3 : 0;
            }

            Readable.ReadableState = ReadableState;

            var debug = debuglog('stream');
            inherits$1(Readable, EventEmitter);

            function prependListener(emitter, event, fn) {
              // Sadly this is not cacheable as some libraries bundle their own
              // event emitter implementation with them.
              if (typeof emitter.prependListener === 'function') {
                return emitter.prependListener(event, fn);
              } else {
                // This is a hack to make sure that our error handler is attached before any
                // userland ones.  NEVER DO THIS. This is here only because this code needs
                // to continue to work with older versions of Node.js that do not include
                // the prependListener() method. The goal is to eventually remove this hack.
                if (!emitter._events || !emitter._events[event])
                  emitter.on(event, fn);
                else if (Array.isArray(emitter._events[event]))
                  emitter._events[event].unshift(fn);
                else
                  emitter._events[event] = [fn, emitter._events[event]];
              }
            }
            function listenerCount$1 (emitter, type) {
              return emitter.listeners(type).length;
            }
            function ReadableState(options, stream) {

              options = options || {};

              // object stream flag. Used to make read(n) ignore n and to
              // make all the buffer merging and length checks go away
              this.objectMode = !!options.objectMode;

              if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

              // the point at which it stops calling _read() to fill the buffer
              // Note: 0 is a valid value, means "don't call _read preemptively ever"
              var hwm = options.highWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

              // cast to ints.
              this.highWaterMark = ~ ~this.highWaterMark;

              // A linked list is used to store data chunks instead of an array because the
              // linked list can remove elements from the beginning faster than
              // array.shift()
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;

              // a flag to be able to tell if the onwrite cb is called immediately,
              // or on a later tick.  We set this to true at first, because any
              // actions that shouldn't happen until "later" should generally also
              // not happen before the first write call.
              this.sync = true;

              // whenever we return null, then we set a flag to say
              // that we're awaiting a 'readable' event emission.
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;

              // Crypto is kind of old and crusty.  Historically, its default string
              // encoding is 'binary' so we have to make this configurable.
              // Everything else in the universe uses 'utf8', though.
              this.defaultEncoding = options.defaultEncoding || 'utf8';

              // when piping, we only care about 'readable' events that happen
              // after read()ing all the bytes and not getting any pushback.
              this.ranOut = false;

              // the number of writers that are awaiting a drain event in .pipe()s
              this.awaitDrain = 0;

              // if true, a maybeReadMore has been scheduled
              this.readingMore = false;

              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {

              if (!(this instanceof Readable)) return new Readable(options);

              this._readableState = new ReadableState(options, this);

              // legacy
              this.readable = true;

              if (options && typeof options.read === 'function') this._read = options.read;

              EventEmitter.call(this);
            }

            // Manually shove something into the read() buffer.
            // This returns true if the highWaterMark has not been hit yet,
            // similar to how Writable.write() returns true if you should
            // write() some more.
            Readable.prototype.push = function (chunk, encoding) {
              var state = this._readableState;

              if (!state.objectMode && typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = '';
                }
              }

              return readableAddChunk(this, state, chunk, encoding, false);
            };

            // Unshift should *always* be something directly out of read()
            Readable.prototype.unshift = function (chunk) {
              var state = this._readableState;
              return readableAddChunk(this, state, chunk, '', true);
            };

            Readable.prototype.isPaused = function () {
              return this._readableState.flowing === false;
            };

            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
              var er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit('error', er);
              } else if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (state.ended && !addToFront) {
                  var e = new Error('stream.push() after EOF');
                  stream.emit('error', e);
                } else if (state.endEmitted && addToFront) {
                  var _e = new Error('stream.unshift() after end event');
                  stream.emit('error', _e);
                } else {
                  var skipAdd;
                  if (state.decoder && !addToFront && !encoding) {
                    chunk = state.decoder.write(chunk);
                    skipAdd = !state.objectMode && chunk.length === 0;
                  }

                  if (!addToFront) state.reading = false;

                  // Don't add to the buffer if we've decoded to an empty string chunk and
                  // we're not in object mode
                  if (!skipAdd) {
                    // if we want the data now, just emit it.
                    if (state.flowing && state.length === 0 && !state.sync) {
                      stream.emit('data', chunk);
                      stream.read(0);
                    } else {
                      // update the buffer info.
                      state.length += state.objectMode ? 1 : chunk.length;
                      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

                      if (state.needReadable) emitReadable(stream);
                    }
                  }

                  maybeReadMore(stream, state);
                }
              } else if (!addToFront) {
                state.reading = false;
              }

              return needMoreData(state);
            }

            // if it's past the high water mark, we can push in some more.
            // Also, if we have no data yet, we can stand some
            // more bytes.  This is to work around cases where hwm=0,
            // such as the repl.  Also, if the push() triggered a
            // readable event, and the user called read(largeNumber) such that
            // needReadable was set, then we ought to push more, so that another
            // 'readable' event will be triggered.
            function needMoreData(state) {
              return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }

            // backwards compatibility.
            Readable.prototype.setEncoding = function (enc) {
              this._readableState.decoder = new StringDecoder(enc);
              this._readableState.encoding = enc;
              return this;
            };

            // Don't raise the hwm > 8MB
            var MAX_HWM = 0x800000;
            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                // Get the next highest power of 2 to prevent increasing hwm excessively in
                // tiny amounts
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }

            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.
            function howMuchToRead(n, state) {
              if (n <= 0 || state.length === 0 && state.ended) return 0;
              if (state.objectMode) return 1;
              if (n !== n) {
                // Only flow one buffer at a time
                if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
              }
              // If we're asking for more than the current hwm, then raise the hwm.
              if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state.length) return n;
              // Don't have enough
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }

            // you can override either this method, or the async _read(n) below.
            Readable.prototype.read = function (n) {
              debug('read', n);
              n = parseInt(n, 10);
              var state = this._readableState;
              var nOrig = n;

              if (n !== 0) state.emittedReadable = false;

              // if we're doing read(0) to trigger a readable event, but we
              // already have a bunch of data in the buffer, then just trigger
              // the 'readable' event and move on.
              if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug('read: emitReadable', state.length, state.ended);
                if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
                return null;
              }

              n = howMuchToRead(n, state);

              // if we've ended, and we're now clear, then finish it up.
              if (n === 0 && state.ended) {
                if (state.length === 0) endReadable(this);
                return null;
              }

              // All the actual chunk generation logic needs to be
              // *below* the call to _read.  The reason is that in certain
              // synthetic stream cases, such as passthrough streams, _read
              // may be a completely synchronous operation which may change
              // the state of the read buffer, providing enough data when
              // before there was *not* enough.
              //
              // So, the steps are:
              // 1. Figure out what the state of things will be after we do
              // a read from the buffer.
              //
              // 2. If that resulting state will trigger a _read, then call _read.
              // Note that this may be asynchronous, or synchronous.  Yes, it is
              // deeply ugly to write APIs this way, but that still doesn't mean
              // that the Readable class should behave improperly, as streams are
              // designed to be sync/async agnostic.
              // Take note if the _read call is sync or async (ie, if the read call
              // has returned yet), so that we know whether or not it's safe to emit
              // 'readable' etc.
              //
              // 3. Actually pull the requested chunks out of the buffer and return.

              // if we need a readable event, then we need to do some reading.
              var doRead = state.needReadable;
              debug('need readable', doRead);

              // if we currently have less than the highWaterMark, then also read some
              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug('length less than watermark', doRead);
              }

              // however, if we've ended, then there's no point, and if we're already
              // reading, then it's unnecessary.
              if (state.ended || state.reading) {
                doRead = false;
                debug('reading or ended', doRead);
              } else if (doRead) {
                debug('do read');
                state.reading = true;
                state.sync = true;
                // if the length is currently zero, then we *need* a readable event.
                if (state.length === 0) state.needReadable = true;
                // call internal read method
                this._read(state.highWaterMark);
                state.sync = false;
                // If _read pushed data synchronously, then `reading` will be false,
                // and we need to re-evaluate how much data we can return to the user.
                if (!state.reading) n = howMuchToRead(nOrig, state);
              }

              var ret;
              if (n > 0) ret = fromList(n, state);else ret = null;

              if (ret === null) {
                state.needReadable = true;
                n = 0;
              } else {
                state.length -= n;
              }

              if (state.length === 0) {
                // If we have nothing in the buffer, then we want to know
                // as soon as we *do* get something into the buffer.
                if (!state.ended) state.needReadable = true;

                // If we tried to read() past the EOF, then emit end on the next tick.
                if (nOrig !== n && state.ended) endReadable(this);
              }

              if (ret !== null) this.emit('data', ret);

              return ret;
            };

            function chunkInvalid(state, chunk) {
              var er = null;
              if (!isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
              }
              return er;
            }

            function onEofChunk(stream, state) {
              if (state.ended) return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;

              // emit 'readable' now to make sure it gets picked up.
              emitReadable(stream);
            }

            // Don't emit readable right away in sync mode, because this can trigger
            // another read() call => stack overflow.  This way, it might trigger
            // a nextTick recursion warning, but that's not so bad.
            function emitReadable(stream) {
              var state = stream._readableState;
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug('emitReadable', state.flowing);
                state.emittedReadable = true;
                if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
              }
            }

            function emitReadable_(stream) {
              debug('emit readable');
              stream.emit('readable');
              flow(stream);
            }

            // at this point, the user has presumably seen the 'readable' event,
            // and called read() to consume some data.  that may have triggered
            // in turn another _read(n) call, in which case reading = true if
            // it's in progress.
            // However, if we're not ended, or reading, and the length < hwm,
            // then go ahead and try to read some more preemptively.
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                nextTick(maybeReadMore_, stream, state);
              }
            }

            function maybeReadMore_(stream, state) {
              var len = state.length;
              while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug('maybeReadMore read 0');
                stream.read(0);
                if (len === state.length)
                  // didn't get any data, stop spinning.
                  break;else len = state.length;
              }
              state.readingMore = false;
            }

            // abstract method.  to be overridden in specific implementation classes.
            // call cb(er, data) where data is <= n in length.
            // for virtual (non-string, non-buffer) streams, "length" is somewhat
            // arbitrary, and perhaps not very meaningful.
            Readable.prototype._read = function (n) {
              this.emit('error', new Error('not implemented'));
            };

            Readable.prototype.pipe = function (dest, pipeOpts) {
              var src = this;
              var state = this._readableState;

              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

              var doEnd = (!pipeOpts || pipeOpts.end !== false);

              var endFn = doEnd ? onend : cleanup;
              if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

              dest.on('unpipe', onunpipe);
              function onunpipe(readable) {
                debug('onunpipe');
                if (readable === src) {
                  cleanup();
                }
              }

              function onend() {
                debug('onend');
                dest.end();
              }

              // when the dest drains, it reduces the awaitDrain counter
              // on the source.  This would be more elegant with a .once()
              // handler in flow(), but adding and removing repeatedly is
              // too slow.
              var ondrain = pipeOnDrain(src);
              dest.on('drain', ondrain);

              var cleanedUp = false;
              function cleanup() {
                debug('cleanup');
                // cleanup event handlers once the pipe is broken
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', cleanup);
                src.removeListener('data', ondata);

                cleanedUp = true;

                // if the reader is waiting for a drain event from this
                // specific writer, then it would cause it to never start
                // flowing again.
                // So, if this is awaiting a drain, then we just call it now.
                // If we don't know, then assume that we are waiting for one.
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
              }

              // If the user pushes more data while we're writing to dest then we'll end up
              // in ondata again. However, we only want to increase awaitDrain once because
              // dest will only emit one 'drain' event for the multiple writes.
              // => Introduce a guard on increasing awaitDrain.
              var increasedAwaitDrain = false;
              src.on('data', ondata);
              function ondata(chunk) {
                debug('ondata');
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                  // If the user unpiped during `dest.write()`, it is possible
                  // to get stuck in a permanently paused state if that write
                  // also returned false.
                  // => Check whether `dest` is still a piping destination.
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug('false write response, pause', src._readableState.awaitDrain);
                    src._readableState.awaitDrain++;
                    increasedAwaitDrain = true;
                  }
                  src.pause();
                }
              }

              // if the dest has an error, then stop piping into it.
              // however, don't suppress the throwing behavior for this.
              function onerror(er) {
                debug('onerror', er);
                unpipe();
                dest.removeListener('error', onerror);
                if (listenerCount$1(dest, 'error') === 0) dest.emit('error', er);
              }

              // Make sure our error handler is attached before userland ones.
              prependListener(dest, 'error', onerror);

              // Both close and finish should trigger unpipe, but only once.
              function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
              }
              dest.once('close', onclose);
              function onfinish() {
                debug('onfinish');
                dest.removeListener('close', onclose);
                unpipe();
              }
              dest.once('finish', onfinish);

              function unpipe() {
                debug('unpipe');
                src.unpipe(dest);
              }

              // tell the dest that it's being piped to
              dest.emit('pipe', src);

              // start the flow if it hasn't been started already.
              if (!state.flowing) {
                debug('pipe resume');
                src.resume();
              }

              return dest;
            };

            function pipeOnDrain(src) {
              return function () {
                var state = src._readableState;
                debug('pipeOnDrain', state.awaitDrain);
                if (state.awaitDrain) state.awaitDrain--;
                if (state.awaitDrain === 0 && src.listeners('data').length) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }

            Readable.prototype.unpipe = function (dest) {
              var state = this._readableState;

              // if we're not piping anywhere, then do nothing.
              if (state.pipesCount === 0) return this;

              // just one destination.  most common case.
              if (state.pipesCount === 1) {
                // passed in one, but it's not the right one.
                if (dest && dest !== state.pipes) return this;

                if (!dest) dest = state.pipes;

                // got a match.
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest) dest.emit('unpipe', this);
                return this;
              }

              // slow case. multiple pipe destinations.

              if (!dest) {
                // remove all.
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;

                for (var _i = 0; _i < len; _i++) {
                  dests[_i].emit('unpipe', this);
                }return this;
              }

              // try to find the right one.
              var i = indexOf(state.pipes, dest);
              if (i === -1) return this;

              state.pipes.splice(i, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1) state.pipes = state.pipes[0];

              dest.emit('unpipe', this);

              return this;
            };

            // set up data events if they are asked for
            // Ensure readable listeners eventually get something
            Readable.prototype.on = function (ev, fn) {
              var res = EventEmitter.prototype.on.call(this, ev, fn);

              if (ev === 'data') {
                // Start flowing on next tick if stream isn't explicitly paused
                if (this._readableState.flowing !== false) this.resume();
              } else if (ev === 'readable') {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.emittedReadable = false;
                  if (!state.reading) {
                    nextTick(nReadingNextTick, this);
                  } else if (state.length) {
                    emitReadable(this, state);
                  }
                }
              }

              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;

            function nReadingNextTick(self) {
              debug('readable nexttick read 0');
              self.read(0);
            }

            // pause() and resume() are remnants of the legacy readable stream API
            // If the user uses them, then switch into old mode.
            Readable.prototype.resume = function () {
              var state = this._readableState;
              if (!state.flowing) {
                debug('resume');
                state.flowing = true;
                resume(this, state);
              }
              return this;
            };

            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                nextTick(resume_, stream, state);
              }
            }

            function resume_(stream, state) {
              if (!state.reading) {
                debug('resume read 0');
                stream.read(0);
              }

              state.resumeScheduled = false;
              state.awaitDrain = 0;
              stream.emit('resume');
              flow(stream);
              if (state.flowing && !state.reading) stream.read(0);
            }

            Readable.prototype.pause = function () {
              debug('call pause flowing=%j', this._readableState.flowing);
              if (false !== this._readableState.flowing) {
                debug('pause');
                this._readableState.flowing = false;
                this.emit('pause');
              }
              return this;
            };

            function flow(stream) {
              var state = stream._readableState;
              debug('flow', state.flowing);
              while (state.flowing && stream.read() !== null) {}
            }

            // wrap an old-style stream as the async data source.
            // This is *not* part of the readable stream interface.
            // It is an ugly unfortunate mess of history.
            Readable.prototype.wrap = function (stream) {
              var state = this._readableState;
              var paused = false;

              var self = this;
              stream.on('end', function () {
                debug('wrapped end');
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) self.push(chunk);
                }

                self.push(null);
              });

              stream.on('data', function (chunk) {
                debug('wrapped data');
                if (state.decoder) chunk = state.decoder.write(chunk);

                // don't skip over falsy values in objectMode
                if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

                var ret = self.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });

              // proxy all the other methods.
              // important when wrapping filters and duplexes.
              for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === 'function') {
                  this[i] = function (method) {
                    return function () {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }

              // proxy certain important events.
              var events = ['error', 'close', 'destroy', 'pause', 'resume'];
              forEach(events, function (ev) {
                stream.on(ev, self.emit.bind(self, ev));
              });

              // when we try to consume some more bytes, simply unpause the
              // underlying stream.
              self._read = function (n) {
                debug('wrapped _read', n);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };

              return self;
            };

            // exposed for testing purposes only.
            Readable._fromList = fromList;

            // Pluck off n bytes from an array of buffers.
            // Length is the combined lengths of all the buffers in the list.
            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.
            function fromList(n, state) {
              // nothing buffered
              if (state.length === 0) return null;

              var ret;
              if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
                // read it all, truncate the list
                if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                // read part of list
                ret = fromListPartial(n, state.buffer, state.decoder);
              }

              return ret;
            }

            // Extracts only enough buffered data to satisfy the amount requested.
            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.
            function fromListPartial(n, list, hasStrings) {
              var ret;
              if (n < list.head.data.length) {
                // slice is the same for buffers and strings
                ret = list.head.data.slice(0, n);
                list.head.data = list.head.data.slice(n);
              } else if (n === list.head.data.length) {
                // first chunk is a perfect match
                ret = list.shift();
              } else {
                // result spans more than one buffer
                ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
              }
              return ret;
            }

            // Copies a specified amount of characters from the list of buffered data
            // chunks.
            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.
            function copyFromBufferString(n, list) {
              var p = list.head;
              var c = 1;
              var ret = p.data;
              n -= ret.length;
              while (p = p.next) {
                var str = p.data;
                var nb = n > str.length ? str.length : n;
                if (nb === str.length) ret += str;else ret += str.slice(0, n);
                n -= nb;
                if (n === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p.next) list.head = p.next;else list.head = list.tail = null;
                  } else {
                    list.head = p;
                    p.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list.length -= c;
              return ret;
            }

            // Copies a specified amount of bytes from the list of buffered data chunks.
            // This function is designed to be inlinable, so please take care when making
            // changes to the function body.
            function copyFromBuffer(n, list) {
              var ret = Buffer.allocUnsafe(n);
              var p = list.head;
              var c = 1;
              p.data.copy(ret);
              n -= p.data.length;
              while (p = p.next) {
                var buf = p.data;
                var nb = n > buf.length ? buf.length : n;
                buf.copy(ret, ret.length - n, 0, nb);
                n -= nb;
                if (n === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p.next) list.head = p.next;else list.head = list.tail = null;
                  } else {
                    list.head = p;
                    p.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list.length -= c;
              return ret;
            }

            function endReadable(stream) {
              var state = stream._readableState;

              // If we get here before consuming all the bytes, then that is a
              // bug in node.  Should never happen.
              if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

              if (!state.endEmitted) {
                state.ended = true;
                nextTick(endReadableNT, state, stream);
              }
            }

            function endReadableNT(state, stream) {
              // Check that we didn't get one last unshift.
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit('end');
              }
            }

            function forEach(xs, f) {
              for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
              }
            }

            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
              }
              return -1;
            }

            // A bit simpler than readable streams.
            Writable.WritableState = WritableState;
            inherits$1(Writable, EventEmitter);

            function nop() {}

            function WriteReq(chunk, encoding, cb) {
              this.chunk = chunk;
              this.encoding = encoding;
              this.callback = cb;
              this.next = null;
            }

            function WritableState(options, stream) {
              Object.defineProperty(this, 'buffer', {
                get: deprecate(function () {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
              });
              options = options || {};

              // object stream flag to indicate whether or not this stream
              // contains buffers or objects.
              this.objectMode = !!options.objectMode;

              if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

              // the point at which write() starts returning false
              // Note: 0 is a valid value, means that we always return false if
              // the entire buffer is not flushed immediately on write()
              var hwm = options.highWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

              // cast to ints.
              this.highWaterMark = ~ ~this.highWaterMark;

              this.needDrain = false;
              // at the start of calling end()
              this.ending = false;
              // when end() has been called, and returned
              this.ended = false;
              // when 'finish' is emitted
              this.finished = false;

              // should we decode strings into buffers before passing to _write?
              // this is here so that some node-core streams can optimize string
              // handling at a lower level.
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;

              // Crypto is kind of old and crusty.  Historically, its default string
              // encoding is 'binary' so we have to make this configurable.
              // Everything else in the universe uses 'utf8', though.
              this.defaultEncoding = options.defaultEncoding || 'utf8';

              // not an actual buffer we keep track of, but a measurement
              // of how much we're waiting to get pushed to some underlying
              // socket or file.
              this.length = 0;

              // a flag to see when we're in the middle of a write.
              this.writing = false;

              // when true all writes will be buffered until .uncork() call
              this.corked = 0;

              // a flag to be able to tell if the onwrite cb is called immediately,
              // or on a later tick.  We set this to true at first, because any
              // actions that shouldn't happen until "later" should generally also
              // not happen before the first write call.
              this.sync = true;

              // a flag to know if we're processing previously buffered items, which
              // may call the _write() callback in the same tick, so that we don't
              // end up in an overlapped onwrite situation.
              this.bufferProcessing = false;

              // the callback that's passed to _write(chunk,cb)
              this.onwrite = function (er) {
                onwrite(stream, er);
              };

              // the callback that the user supplies to write(chunk,encoding,cb)
              this.writecb = null;

              // the amount that is being written when _write is called.
              this.writelen = 0;

              this.bufferedRequest = null;
              this.lastBufferedRequest = null;

              // number of pending user-supplied write callbacks
              // this must be 0 before 'finish' can be emitted
              this.pendingcb = 0;

              // emit prefinish if the only thing we're waiting for is _write cbs
              // This is relevant for synchronous Transform streams
              this.prefinished = false;

              // True if the error was already emitted and should not be thrown again
              this.errorEmitted = false;

              // count buffered requests
              this.bufferedRequestCount = 0;

              // allocate the first CorkedRequest, there is always
              // one allocated and free to use, and we maintain at most two
              this.corkedRequestsFree = new CorkedRequest(this);
            }

            WritableState.prototype.getBuffer = function writableStateGetBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            function Writable(options) {

              // Writable ctor is applied to Duplexes, though they're not
              // instanceof Writable, they're instanceof Readable.
              if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

              this._writableState = new WritableState(options, this);

              // legacy.
              this.writable = true;

              if (options) {
                if (typeof options.write === 'function') this._write = options.write;

                if (typeof options.writev === 'function') this._writev = options.writev;
              }

              EventEmitter.call(this);
            }

            // Otherwise people can pipe Writable streams, which is just wrong.
            Writable.prototype.pipe = function () {
              this.emit('error', new Error('Cannot pipe, not readable'));
            };

            function writeAfterEnd(stream, cb) {
              var er = new Error('write after end');
              // TODO: defer error events consistently everywhere, not just the cb
              stream.emit('error', er);
              nextTick(cb, er);
            }

            // If we get something that is not a buffer, string, null, or undefined,
            // and we're not in objectMode, then that's an error.
            // Otherwise stream chunks are all considered to be of length=1, and the
            // watermarks determine how many objects to keep in the buffer, rather than
            // how many bytes or characters.
            function validChunk(stream, state, chunk, cb) {
              var valid = true;
              var er = false;
              // Always throw error if a null is written
              // if we are not in object mode then throw
              // if it is not a buffer, string, or undefined.
              if (chunk === null) {
                er = new TypeError('May not write null values to stream');
              } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
              }
              if (er) {
                stream.emit('error', er);
                nextTick(cb, er);
                valid = false;
              }
              return valid;
            }

            Writable.prototype.write = function (chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;

              if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
              }

              if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

              if (typeof cb !== 'function') cb = nop;

              if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, chunk, encoding, cb);
              }

              return ret;
            };

            Writable.prototype.cork = function () {
              var state = this._writableState;

              state.corked++;
            };

            Writable.prototype.uncork = function () {
              var state = this._writableState;

              if (state.corked) {
                state.corked--;

                if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
              }
            };

            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              // node::ParseEncoding() requires lower case.
              if (typeof encoding === 'string') encoding = encoding.toLowerCase();
              if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };

            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
                chunk = Buffer.from(chunk, encoding);
              }
              return chunk;
            }

            // if we're already writing something, then just put this
            // in the queue, and wait our turn.  Otherwise, call _write
            // If we return false, then we need a drain event, so set that flag.
            function writeOrBuffer(stream, state, chunk, encoding, cb) {
              chunk = decodeChunk(state, chunk, encoding);

              if (Buffer.isBuffer(chunk)) encoding = 'buffer';
              var len = state.objectMode ? 1 : chunk.length;

              state.length += len;

              var ret = state.length < state.highWaterMark;
              // we must ensure that previous needDrain will not be reset to false.
              if (!ret) state.needDrain = true;

              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }

              return ret;
            }

            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }

            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) nextTick(cb, er);else cb(er);

              stream._writableState.errorEmitted = true;
              stream.emit('error', er);
            }

            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }

            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;

              onwriteStateUpdate(state);

              if (er) onwriteError(stream, state, sync, er, cb);else {
                // Check if we're actually ready to finish, but don't emit yet
                var finished = needFinish(state);

                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }

                if (sync) {
                  /*<replacement>*/
                    nextTick(afterWrite, stream, state, finished, cb);
                  /*</replacement>*/
                } else {
                    afterWrite(stream, state, finished, cb);
                  }
              }
            }

            function afterWrite(stream, state, finished, cb) {
              if (!finished) onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }

            // Must force callback to be called on nextTick, so that we don't
            // emit 'drain' before the write() consumer gets the 'false' return
            // value, and has a chance to attach a 'drain' listener.
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit('drain');
              }
            }

            // if there's something in the buffer waiting, then process it
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;

              if (stream._writev && entry && entry.next) {
                // Fast case, write everything using _writev()
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;

                var count = 0;
                while (entry) {
                  buffer[count] = entry;
                  entry = entry.next;
                  count += 1;
                }

                doWrite(stream, state, true, state.length, buffer, '', holder.finish);

                // doWrite is almost always async, defer these to save a bit of time
                // as the hot path ends with doWrite
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
              } else {
                // Slow case, write chunks one-by-one
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;

                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  // if we didn't call the onwrite immediately, then
                  // it means that we need to wait until it does.
                  // also, that means that the chunk and cb are currently
                  // being processed, so move the buffer counter past them.
                  if (state.writing) {
                    break;
                  }
                }

                if (entry === null) state.lastBufferedRequest = null;
              }

              state.bufferedRequestCount = 0;
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }

            Writable.prototype._write = function (chunk, encoding, cb) {
              cb(new Error('not implemented'));
            };

            Writable.prototype._writev = null;

            Writable.prototype.end = function (chunk, encoding, cb) {
              var state = this._writableState;

              if (typeof chunk === 'function') {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
              }

              if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

              // .end() fully uncorks
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }

              // ignore unnecessary end() calls.
              if (!state.ending && !state.finished) endWritable(this, state, cb);
            };

            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }

            function prefinish(stream, state) {
              if (!state.prefinished) {
                state.prefinished = true;
                stream.emit('prefinish');
              }
            }

            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                if (state.pendingcb === 0) {
                  prefinish(stream, state);
                  state.finished = true;
                  stream.emit('finish');
                } else {
                  prefinish(stream, state);
                }
              }
              return need;
            }

            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished) nextTick(cb);else stream.once('finish', cb);
              }
              state.ended = true;
              stream.writable = false;
            }

            // It seems a linked list but it is not
            // there will be only 2 of these for each stream
            function CorkedRequest(state) {
              var _this = this;

              this.next = null;
              this.entry = null;

              this.finish = function (err) {
                var entry = _this.entry;
                _this.entry = null;
                while (entry) {
                  var cb = entry.callback;
                  state.pendingcb--;
                  cb(err);
                  entry = entry.next;
                }
                if (state.corkedRequestsFree) {
                  state.corkedRequestsFree.next = _this;
                } else {
                  state.corkedRequestsFree = _this;
                }
              };
            }

            inherits$1(Duplex, Readable);

            var keys = Object.keys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v];
              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
            }
            function Duplex(options) {
              if (!(this instanceof Duplex)) return new Duplex(options);

              Readable.call(this, options);
              Writable.call(this, options);

              if (options && options.readable === false) this.readable = false;

              if (options && options.writable === false) this.writable = false;

              this.allowHalfOpen = true;
              if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

              this.once('end', onend);
            }

            // the no-half-open enforcer
            function onend() {
              // if we allow half-open state, or if the writable side ended,
              // then we're ok.
              if (this.allowHalfOpen || this._writableState.ended) return;

              // no more data can be written.
              // But allow more writes to happen in this tick.
              nextTick(onEndNT, this);
            }

            function onEndNT(self) {
              self.end();
            }

            // a transform stream is a readable/writable stream where you do
            inherits$1(Transform, Duplex);

            function TransformState(stream) {
              this.afterTransform = function (er, data) {
                return afterTransform(stream, er, data);
              };

              this.needTransform = false;
              this.transforming = false;
              this.writecb = null;
              this.writechunk = null;
              this.writeencoding = null;
            }

            function afterTransform(stream, er, data) {
              var ts = stream._transformState;
              ts.transforming = false;

              var cb = ts.writecb;

              if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

              ts.writechunk = null;
              ts.writecb = null;

              if (data !== null && data !== undefined) stream.push(data);

              cb(er);

              var rs = stream._readableState;
              rs.reading = false;
              if (rs.needReadable || rs.length < rs.highWaterMark) {
                stream._read(rs.highWaterMark);
              }
            }
            function Transform(options) {
              if (!(this instanceof Transform)) return new Transform(options);

              Duplex.call(this, options);

              this._transformState = new TransformState(this);

              // when the writable side finishes, then flush out anything remaining.
              var stream = this;

              // start out asking for a readable event once data is transformed.
              this._readableState.needReadable = true;

              // we have implemented the _read method, and done the other things
              // that Readable wants before the first _read call, so unset the
              // sync guard flag.
              this._readableState.sync = false;

              if (options) {
                if (typeof options.transform === 'function') this._transform = options.transform;

                if (typeof options.flush === 'function') this._flush = options.flush;
              }

              this.once('prefinish', function () {
                if (typeof this._flush === 'function') this._flush(function (er) {
                  done(stream, er);
                });else done(stream);
              });
            }

            Transform.prototype.push = function (chunk, encoding) {
              this._transformState.needTransform = false;
              return Duplex.prototype.push.call(this, chunk, encoding);
            };

            // This is the part where you do stuff!
            // override this function in implementation classes.
            // 'chunk' is an input chunk.
            //
            // Call `push(newChunk)` to pass along transformed output
            // to the readable side.  You may call 'push' zero or more times.
            //
            // Call `cb(err)` when you are done with this chunk.  If you pass
            // an error, then that'll put the hurt on the whole operation.  If you
            // never call cb(), then you'll never get another chunk.
            Transform.prototype._transform = function (chunk, encoding, cb) {
              throw new Error('Not implemented');
            };

            Transform.prototype._write = function (chunk, encoding, cb) {
              var ts = this._transformState;
              ts.writecb = cb;
              ts.writechunk = chunk;
              ts.writeencoding = encoding;
              if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
              }
            };

            // Doesn't matter what the args are here.
            // _transform does all the work.
            // That we got here means that the readable side wants more data.
            Transform.prototype._read = function (n) {
              var ts = this._transformState;

              if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
              } else {
                // mark that we need a transform, so that any data that comes in
                // will get processed, now that we've asked for it.
                ts.needTransform = true;
              }
            };

            function done(stream, er) {
              if (er) return stream.emit('error', er);

              // if there's nothing in the write buffer, then that means
              // that nothing more will ever be provided
              var ws = stream._writableState;
              var ts = stream._transformState;

              if (ws.length) throw new Error('Calling transform done when ws.length != 0');

              if (ts.transforming) throw new Error('Calling transform done when still transforming');

              return stream.push(null);
            }

            inherits$1(PassThrough, Transform);
            function PassThrough(options) {
              if (!(this instanceof PassThrough)) return new PassThrough(options);

              Transform.call(this, options);
            }

            PassThrough.prototype._transform = function (chunk, encoding, cb) {
              cb(null, chunk);
            };

            inherits$1(Stream, EventEmitter);
            Stream.Readable = Readable;
            Stream.Writable = Writable;
            Stream.Duplex = Duplex;
            Stream.Transform = Transform;
            Stream.PassThrough = PassThrough;

            // Backwards-compat with node 0.4.x
            Stream.Stream = Stream;

            // old-style streams.  Note that the pipe method (the only relevant
            // part of this class) is overridden in the Readable class.

            function Stream() {
              EventEmitter.call(this);
            }

            Stream.prototype.pipe = function(dest, options) {
              var source = this;

              function ondata(chunk) {
                if (dest.writable) {
                  if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                  }
                }
              }

              source.on('data', ondata);

              function ondrain() {
                if (source.readable && source.resume) {
                  source.resume();
                }
              }

              dest.on('drain', ondrain);

              // If the 'end' option is not supplied, dest.end() will be called when
              // source gets the 'end' or 'close' events.  Only dest.end() once.
              if (!dest._isStdio && (!options || options.end !== false)) {
                source.on('end', onend);
                source.on('close', onclose);
              }

              var didOnEnd = false;
              function onend() {
                if (didOnEnd) return;
                didOnEnd = true;

                dest.end();
              }


              function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;

                if (typeof dest.destroy === 'function') dest.destroy();
              }

              // don't leave dangling pipes when there are errors.
              function onerror(er) {
                cleanup();
                if (EventEmitter.listenerCount(this, 'error') === 0) {
                  throw er; // Unhandled stream error in pipe.
                }
              }

              source.on('error', onerror);
              dest.on('error', onerror);

              // remove all the event listeners that were added.
              function cleanup() {
                source.removeListener('data', ondata);
                dest.removeListener('drain', ondrain);

                source.removeListener('end', onend);
                source.removeListener('close', onclose);

                source.removeListener('error', onerror);
                dest.removeListener('error', onerror);

                source.removeListener('end', cleanup);
                source.removeListener('close', cleanup);

                dest.removeListener('close', cleanup);
              }

              source.on('end', cleanup);
              source.on('close', cleanup);

              dest.on('close', cleanup);

              dest.emit('pipe', source);

              // Allow for unix-like usage: A.pipe(B).pipe(C)
              return dest;
            };

            var stream = /*#__PURE__*/Object.freeze({
                        default: Stream,
                        Readable: Readable,
                        Writable: Writable,
                        Duplex: Duplex,
                        Transform: Transform,
                        PassThrough: PassThrough,
                        Stream: Stream
            });

            var require$$0 = ( stream && Stream ) || stream;

            var through_1 = createCommonjsModule(function (module, exports) {
            // through
            //
            // a stream that does nothing but re-emit the input.
            // useful for aggregating a series of changing but not ending streams into one stream)

            exports = module.exports = through;
            through.through = through;

            //create a readable writable stream.

            function through (write, end, opts) {
              write = write || function (data) { this.queue(data); };
              end = end || function () { this.queue(null); };

              var ended = false, destroyed = false, buffer = [], _ended = false;
              var stream = new require$$0();
              stream.readable = stream.writable = true;
              stream.paused = false;

            //  stream.autoPause   = !(opts && opts.autoPause   === false)
              stream.autoDestroy = !(opts && opts.autoDestroy === false);

              stream.write = function (data) {
                write.call(this, data);
                return !stream.paused
              };

              function drain() {
                while(buffer.length && !stream.paused) {
                  var data = buffer.shift();
                  if(null === data)
                    return stream.emit('end')
                  else
                    stream.emit('data', data);
                }
              }

              stream.queue = stream.push = function (data) {
            //    console.error(ended)
                if(_ended) return stream
                if(data === null) _ended = true;
                buffer.push(data);
                drain();
                return stream
              };

              //this will be registered as the first 'end' listener
              //must call destroy next tick, to make sure we're after any
              //stream piped from here.
              //this is only a problem if end is not emitted synchronously.
              //a nicer way to do this is to make sure this is the last listener for 'end'

              stream.on('end', function () {
                stream.readable = false;
                if(!stream.writable && stream.autoDestroy)
                  nextTick(function () {
                    stream.destroy();
                  });
              });

              function _end () {
                stream.writable = false;
                end.call(stream);
                if(!stream.readable && stream.autoDestroy)
                  stream.destroy();
              }

              stream.end = function (data) {
                if(ended) return
                ended = true;
                if(arguments.length) stream.write(data);
                _end(); // will emit or queue
                return stream
              };

              stream.destroy = function () {
                if(destroyed) return
                destroyed = true;
                ended = true;
                buffer.length = 0;
                stream.writable = stream.readable = false;
                stream.emit('close');
                return stream
              };

              stream.pause = function () {
                if(stream.paused) return
                stream.paused = true;
                return stream
              };

              stream.resume = function () {
                if(stream.paused) {
                  stream.paused = false;
                  stream.emit('resume');
                }
                drain();
                //may have become paused again,
                //as drain emits 'data'.
                if(!stream.paused)
                  stream.emit('drain');
                return stream
              };
              return stream
            }
            });

            var writeMethods = ["write", "end", "destroy"];
            var readMethods = ["resume", "pause"];
            var readEvents = ["data", "close"];
            var slice = Array.prototype.slice;

            var duplexer = duplex;

            function forEach$1 (arr, fn) {
                if (arr.forEach) {
                    return arr.forEach(fn)
                }

                for (var i = 0; i < arr.length; i++) {
                    fn(arr[i], i);
                }
            }

            function duplex(writer, reader) {
                var stream = new require$$0();
                var ended = false;

                forEach$1(writeMethods, proxyWriter);

                forEach$1(readMethods, proxyReader);

                forEach$1(readEvents, proxyStream);

                reader.on("end", handleEnd);

                writer.on("drain", function() {
                  stream.emit("drain");
                });

                writer.on("error", reemit);
                reader.on("error", reemit);

                stream.writable = writer.writable;
                stream.readable = reader.readable;

                return stream

                function proxyWriter(methodName) {
                    stream[methodName] = method;

                    function method() {
                        return writer[methodName].apply(writer, arguments)
                    }
                }

                function proxyReader(methodName) {
                    stream[methodName] = method;

                    function method() {
                        stream.emit(methodName);
                        var func = reader[methodName];
                        if (func) {
                            return func.apply(reader, arguments)
                        }
                        reader.emit(methodName);
                    }
                }

                function proxyStream(methodName) {
                    reader.on(methodName, reemit);

                    function reemit() {
                        var args = slice.call(arguments);
                        args.unshift(methodName);
                        stream.emit.apply(stream, args);
                    }
                }

                function handleEnd() {
                    if (ended) {
                        return
                    }
                    ended = true;
                    var args = slice.call(arguments);
                    args.unshift("end");
                    stream.emit.apply(stream, args);
                }

                function reemit(err) {
                    stream.emit("error", err);
                }
            }

            var duplexer$1 = /*#__PURE__*/Object.freeze({
                        default: duplexer,
                        __moduleExports: duplexer
            });

            var duplexer$2 = ( duplexer$1 && duplexer ) || duplexer$1;

            var streamCombiner = function () {
              var streams;

              if(arguments.length == 1 && Array.isArray(arguments[0])) {
                streams = arguments[0];
              } else {
                streams = [].slice.call(arguments);
              }

              if(streams.length == 0)
                return through_1()
              else if(streams.length == 1)
                return streams[0]

              var first = streams[0]
                , last = streams[streams.length - 1]
                , thepipe = duplexer$2(first, last);

              //pipe all the streams together

              function recurse (streams) {
                if(streams.length < 2)
                  return
                streams[0].pipe(streams[1]);
                recurse(streams.slice(1));
              }

              recurse(streams);

              function onerror () {
                var args = [].slice.call(arguments);
                args.unshift('error');
                thepipe.emit.apply(thepipe, args);
              }

              //es.duplex already reemits the error from the first and last stream.
              //add a listener for the inner streams in the pipeline.
              for(var i = 1; i < streams.length - 1; i ++)
                streams[i].on('error', onerror);

              return thepipe
            };

            function streamToCb(stream, cb) {
              var chunks = [];
              var complete;
              stream.on('data', function (d) {
                chunks.push(d);
              });
              stream.on('end', function () {
                if (!complete) {
                  complete = true;
                  cb(null, Buffer.concat(chunks));
                }
              });
              stream.on('error', function (e) {
                if (!complete) {
                  complete = true;
                  cb(e);
                }
              });
            }

            function chunkSizeSafe(size) {
              var last;
              return through_1(function (d) {
                if (last) d = Buffer.concat([last, d]);
                var end = Math.floor(d.length / size) * size;

                if (!end) {
                  last = last ? Buffer.concat([last, d]) : d;
                } else if (d.length > end) {
                  last = d.slice(end);
                  this.emit('data', d.slice(0, end));
                } else {
                  last = undefined;
                  this.emit('data', d);
                }
              }, function () {
                if (last) this.emit('data', last);
                this.emit('end');
              });
            }

            function detectSize(cb) {
              var chunks = [];
              var size = 0;
              return through_1(function (d) {
                chunks.push(d);
                size += d.length;
              }, function () {
                // function IS needed
                cb(size);
                chunks.forEach(this.emit.bind(this, 'data'));
                this.emit('end');
              });
            }

            var empty = {};

            var empty$1 = /*#__PURE__*/Object.freeze({
                        default: empty
            });

            var require$$0$1 = ( empty$1 && empty ) || empty$1;

            var secureRandom = createCommonjsModule(function (module) {
            !function(globals){

            //*** UMD BEGIN
            if (typeof undefined !== 'undefined' && undefined.amd) { //require.js / AMD
              undefined([], function() {
                return secureRandom
              });
            } else if (module.exports) { //CommonJS
              module.exports = secureRandom;
            } else { //script / browser
              globals.secureRandom = secureRandom;
            }
            //*** UMD END

            //options.type is the only valid option
            function secureRandom(count, options) {
              options = options || {type: 'Array'};
              //we check for process.pid to prevent browserify from tricking us
              if (
                typeof process != 'undefined'
                && typeof process.pid == 'number'
                && process.versions
                && process.versions.node
              ) {
                return nodeRandom(count, options)
              } else {
                var crypto = window.crypto || window.msCrypto;
                if (!crypto) throw new Error("Your browser does not support window.crypto.")
                return browserRandom(count, options)
              }
            }

            function nodeRandom(count, options) {
              var crypto = require$$0$1;
              var buf = crypto.randomBytes(count);

              switch (options.type) {
                case 'Array':
                  return [].slice.call(buf)
                case 'Buffer':
                  return buf
                case 'Uint8Array':
                  var arr = new Uint8Array(count);
                  for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i); }
                  return arr
                default:
                  throw new Error(options.type + " is unsupported.")
              }
            }

            function browserRandom(count, options) {
              var nativeArr = new Uint8Array(count);
              var crypto = window.crypto || window.msCrypto;
              crypto.getRandomValues(nativeArr);

              switch (options.type) {
                case 'Array':
                  return [].slice.call(nativeArr)
                case 'Buffer':
                  try { var b = new Buffer(1); } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
                  return new Buffer(nativeArr)
                case 'Uint8Array':
                  return nativeArr
                default:
                  throw new Error(options.type + " is unsupported.")
              }
            }

            secureRandom.randomArray = function(byteCount) {
              return secureRandom(byteCount, {type: 'Array'})
            };

            secureRandom.randomUint8Array = function(byteCount) {
              return secureRandom(byteCount, {type: 'Uint8Array'})
            };

            secureRandom.randomBuffer = function(byteCount) {
              return secureRandom(byteCount, {type: 'Buffer'})
            };


            }(commonjsGlobal);
            });

            function _typeof(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function (obj) {
                  return typeof obj;
                };
              } else {
                _typeof = function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }

              return _typeof(obj);
            }

            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }

            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps) _defineProperties(Constructor.prototype, protoProps);
              if (staticProps) _defineProperties(Constructor, staticProps);
              return Constructor;
            }

            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }

              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) _setPrototypeOf(subClass, superClass);
            }

            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
              };
              return _getPrototypeOf(o);
            }

            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
              };

              return _setPrototypeOf(o, p);
            }

            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct) return false;
              if (Reflect.construct.sham) return false;
              if (typeof Proxy === "function") return true;

              try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
                return true;
              } catch (e) {
                return false;
              }
            }

            function _assertThisInitialized(self) {
              if (self === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }

              return self;
            }

            function _possibleConstructorReturn(self, call) {
              if (call && (typeof call === "object" || typeof call === "function")) {
                return call;
              }

              return _assertThisInitialized(self);
            }

            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();

              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived),
                    result;

                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;

                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }

                return _possibleConstructorReturn(this, result);
              };
            }

            function _slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
            }

            function _arrayWithHoles(arr) {
              if (Array.isArray(arr)) return arr;
            }

            function _iterableToArrayLimit(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            function _unsupportedIterableToArray(o, minLen) {
              if (!o) return;
              if (typeof o === "string") return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor) n = o.constructor.name;
              if (n === "Map" || n === "Set") return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }

            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length;

              for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

              return arr2;
            }

            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }

            function _createForOfIteratorHelper(o, allowArrayLike) {
              var it;

              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it) o = it;
                  var i = 0;

                  var F = function () {};

                  return {
                    s: F,
                    n: function () {
                      if (i >= o.length) return {
                        done: true
                      };
                      return {
                        done: false,
                        value: o[i++]
                      };
                    },
                    e: function (e) {
                      throw e;
                    },
                    f: F
                  };
                }

                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }

              var normalCompletion = true,
                  didErr = false,
                  err;
              return {
                s: function () {
                  it = o[Symbol.iterator]();
                },
                n: function () {
                  var step = it.next();
                  normalCompletion = step.done;
                  return step;
                },
                e: function (e) {
                  didErr = true;
                  err = e;
                },
                f: function () {
                  try {
                    if (!normalCompletion && it.return != null) it.return();
                  } finally {
                    if (didErr) throw err;
                  }
                }
              };
            }

            /** @fileOverview Low-level AES implementation.
             *
             * This file contains a low-level implementation of AES, optimized for
             * size and for efficiency on several browsers.  It is based on
             * OpenSSL's aes_core.c, a public-domain implementation by Vincent
             * Rijmen, Antoon Bosselaers and Paulo Barreto.
             *
             * An older version of this implementation is available in the public
             * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
             * Stanford University 2008-2010 and BSD-licensed for liability
             * reasons.
             *
             * @author Emily Stark
             * @author Mike Hamburg
             * @author Dan Boneh
             */

            /**
             * Schedule out an AES key for both encryption and decryption.  This
             * is a low-level class.  Use a cipher mode to do bulk encryption.
             *
             * @constructor
             * @param {Array} key The key as an array of 4, 6 or 8 words.
             *
             * @class Advanced Encryption Standard (low-level interface)
             */
            var AES = /*#__PURE__*/function () {
              function AES(key) {
                _classCallCheck(this, AES);

                if (!this._tables[0][0][0]) {
                  this._precompute();
                }

                var i;
                var j;
                var tmp;
                var encKey;
                var decKey;
                var sbox = this._tables[0][4];
                var decTable = this._tables[1];
                var keyLen = key.length;
                var rcon = 1;

                if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
                  throw new Error('invalid aes key size');
                }

                this._key = [encKey = key.slice(0), decKey = []]; // schedule encryption keys

                for (i = keyLen; i < 4 * keyLen + 28; i++) {
                  tmp = encKey[i - 1]; // apply sbox

                  if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                    tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon

                    if (i % keyLen === 0) {
                      tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                      rcon = rcon << 1 ^ (rcon >> 7) * 283;
                    }
                  }

                  encKey[i] = encKey[i - keyLen] ^ tmp;
                } // schedule decryption keys


                for (j = 0; i; j++, i--) {
                  tmp = encKey[j & 3 ? i : i - 4];

                  if (i <= 4 || j < 4) {
                    decKey[j] = tmp;
                  } else {
                    decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
                  }
                }
              } // public

              /* Something like this might appear here eventually
              name: "AES",
              blockSize: 4,
              keySizes: [4,6,8],
              */

              /**
               * Encrypt an array of 4 big-endian words.
               * @param {Array} data The plaintext.
               * @return {Array} The ciphertext.
               */


              _createClass(AES, [{
                key: "encrypt",
                value: function encrypt(data) {
                  return this._crypt(data, 0);
                }
                /**
                 * Decrypt an array of 4 big-endian words.
                 * @param {Array} data The ciphertext.
                 * @return {Array} The plaintext.
                 */

              }, {
                key: "decrypt",
                value: function decrypt(data) {
                  return this._crypt(data, 1);
                }
                /**
                 * Expand the S-box tables.
                 *
                 * @private
                 */

              }, {
                key: "_precompute",
                value: function _precompute() {
                  var encTable = this._tables[0];
                  var decTable = this._tables[1];
                  var sbox = encTable[4];
                  var sboxInv = decTable[4];
                  var i;
                  var x;
                  var xInv;
                  var d = [];
                  var th = [];
                  var x2;
                  var x4;
                  var x8;
                  var s;
                  var tEnc;
                  var tDec; // Compute double and third tables

                  for (i = 0; i < 256; i++) {
                    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
                  }

                  for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
                    // Compute sbox
                    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
                    s = s >> 8 ^ s & 255 ^ 99;
                    sbox[x] = s;
                    sboxInv[s] = x; // Compute MixColumns

                    x8 = d[x4 = d[x2 = d[x]]];
                    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
                    tEnc = d[s] * 0x101 ^ s * 0x1010100;

                    for (i = 0; i < 4; i++) {
                      encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                      decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
                    }
                  } // Compactify.  Considerable speedup on Firefox.


                  for (i = 0; i < 5; i++) {
                    encTable[i] = encTable[i].slice(0);
                    decTable[i] = decTable[i].slice(0);
                  }
                }
                /**
                 * Encryption and decryption core.
                 * @param {Array} input Four words to be encrypted or decrypted.
                 * @param dir The direction, 0 for encrypt and 1 for decrypt.
                 * @return {Array} The four encrypted or decrypted words.
                 * @private
                 */

              }, {
                key: "_crypt",
                value: function _crypt(input, dir) {
                  if (input.length !== 4) {
                    throw new Error('invalid aes block size');
                  } // state variables a,b,c,d are loaded with pre-whitened data


                  var key = this._key[dir];
                  var a = input[0] ^ key[0];
                  var b = input[dir ? 3 : 1] ^ key[1];
                  var c = input[2] ^ key[2];
                  var d = input[dir ? 1 : 3] ^ key[3];
                  var a2;
                  var b2;
                  var c2;
                  var nInnerRounds = key.length / 4 - 2;
                  var i;
                  var kIndex = 4;
                  var out = [0, 0, 0, 0]; // load up the tables

                  var table = this._tables[dir];
                  var t0 = table[0];
                  var t1 = table[1];
                  var t2 = table[2];
                  var t3 = table[3];
                  var sbox = table[4]; // Inner rounds.  Cribbed from OpenSSL.

                  for (i = 0; i < nInnerRounds; i++) {
                    a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
                    b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
                    c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
                    d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
                    kIndex += 4;
                    a = a2;
                    b = b2;
                    c = c2;
                  } // Last round.


                  for (i = 0; i < 4; i++) {
                    out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
                    a2 = a;
                    a = b;
                    b = c;
                    c = d;
                    d = a2;
                  }

                  return out;
                }
              }]);

              return AES;
            }();
            /**
             * The expanded S-box and inverse S-box tables.  These will be computed
             * on the client so that we don't have to send them down the wire.
             *
             * There are two tables, _tables[0] is for encryption and
             * _tables[1] is for decryption.
             *
             * The first 4 sub-tables are the expanded S-box with MixColumns.  The
             * last (_tables[01][4]) is the S-box itself.
             *
             * @private
             */


            AES.prototype._tables = [[[], [], [], [], []], [[], [], [], [], []]];

            function prepareKey(password) {
              var i, j, r;
              var pkey = [0x93C467E3, 0x7DB0C7A4, 0xD1BE3F81, 0x0152CB56];

              for (r = 65536; r--;) {
                for (j = 0; j < password.length; j += 16) {
                  var _key = [0, 0, 0, 0];

                  for (i = 0; i < 16; i += 4) {
                    if (i + j < password.length) {
                      _key[i / 4] = password.readInt32BE(i + j);
                    }
                  }

                  pkey = new AES(_key).encrypt(pkey);
                }
              }

              var key = Buffer.allocUnsafe(16);

              for (i = 0; i < 4; i++) {
                key.writeInt32BE(pkey[i], i * 4);
              }

              return key;
            } // The same function but for version 2 accounts

            function prepareKeyV2(password, info, cb) {
              var salt = Buffer.from(info.s, 'base64');
              var iterations = 100000;
              var digest = 'SHA-512';
              window.crypto.subtle.importKey('raw', password, {
                name: 'PBKDF2'
              }, false, 'deriveKey').then(function (key) {
                return window.crypto.subtle.deriveBits({
                  name: 'PBKDF2',
                  salt: salt,
                  iterations: iterations,
                  hash: {
                    name: digest
                  }
                }, key, 256);
              }).then(function (result) {
                cb(null, Buffer.from(result));
              }).catch(cb);
            }

            var AES$1 = /*#__PURE__*/function () {
              function AES$$1(key) {
                _classCallCheck(this, AES$$1);

                if (key.length !== 16) throw Error('Wrong key length. Key must be 128bit.');
                var a32 = [];

                for (var i = 0; i < 4; i++) {
                  a32[i] = key.readInt32BE(i * 4);
                }

                this.aes = new AES(a32);
              }

              _createClass(AES$$1, [{
                key: "encryptCBC",
                value: function encryptCBC(buffer) {
                  var iv = [0, 0, 0, 0];
                  var d = Array(4);
                  var i, j;

                  for (i = 0; i < buffer.length; i += 16) {
                    for (j = 0; j < 4; j++) {
                      d[j] = buffer.readUInt32BE(i + j * 4) ^ iv[j];
                    }

                    iv = this.aes.encrypt(d);

                    for (j = 0; j < 4; j++) {
                      buffer.writeInt32BE(iv[j], i + j * 4);
                    }
                  }
                }
              }, {
                key: "decryptCBC",
                value: function decryptCBC(buffer) {
                  var iv = [0, 0, 0, 0];
                  var d = Array(4);
                  var t = Array(4);
                  var i, j;

                  for (i = 0; i < buffer.length; i += 16) {
                    for (j = 0; j < 4; j++) {
                      d[j] = buffer.readUInt32BE(i + j * 4);
                    }

                    t = d;
                    d = this.aes.decrypt(d);

                    for (j = 0; j < 4; j++) {
                      buffer.writeInt32BE(d[j] ^ iv[j], i + j * 4);
                    }

                    iv = t;
                  }
                }
              }, {
                key: "stringhash",
                value: function stringhash(buffer) {
                  var h32 = [0, 0, 0, 0];

                  for (var i = 0; i < buffer.length; i += 4) {
                    if (buffer.length - i < 4) {
                      var len = buffer.length - i;
                      h32[i / 4 & 3] ^= buffer.readIntBE(i, len) << (4 - len) * 8;
                    } else {
                      h32[i / 4 & 3] ^= buffer.readInt32BE(i);
                    }
                  }

                  for (var _i = 16384; _i--;) {
                    h32 = this.aes.encrypt(h32);
                  }

                  var b = Buffer.allocUnsafe(8);
                  b.writeInt32BE(h32[0], 0);
                  b.writeInt32BE(h32[2], 4);
                  return b;
                }
              }, {
                key: "encryptECB",
                value: function encryptECB(key) {
                  var d = [];

                  for (var i = 0; i < key.length; i += 16) {
                    d[0] = key.readInt32BE(i);
                    d[1] = key.readInt32BE(i + 4);
                    d[2] = key.readInt32BE(i + 8);
                    d[3] = key.readInt32BE(i + 12);
                    d = this.aes.encrypt(d);
                    key.writeInt32BE(d[0], i);
                    key.writeInt32BE(d[1], i + 4);
                    key.writeInt32BE(d[2], i + 8);
                    key.writeInt32BE(d[3], i + 12);
                  }

                  return key;
                }
              }, {
                key: "decryptECB",
                value: function decryptECB(key) {
                  var d = [];

                  for (var i = 0; i < key.length; i += 16) {
                    d[0] = key.readInt32BE(i);
                    d[1] = key.readInt32BE(i + 4);
                    d[2] = key.readInt32BE(i + 8);
                    d[3] = key.readInt32BE(i + 12);
                    d = this.aes.decrypt(d);
                    key.writeInt32BE(d[0], i);
                    key.writeInt32BE(d[1], i + 4);
                    key.writeInt32BE(d[2], i + 8);
                    key.writeInt32BE(d[3], i + 12);
                  }

                  return key;
                }
              }]);

              return AES$$1;
            }();

            var CTR = /*#__PURE__*/function () {
              function CTR(aes, nonce) {
                var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                _classCallCheck(this, CTR);

                this.aes = aes;
                this.nonce = nonce.slice(0, 8);
                this.increment = 131072; // 2**17

                this.posNext = this.increment;
                this.pos = 0;
                this.ctr = Buffer.alloc(16);
                this.nonce.copy(this.ctr, 0);
                this.mac = Buffer.alloc(16);
                this.nonce.copy(this.mac, 0);
                this.nonce.copy(this.mac, 8);
                this.macs = [];
                this.incrementCTR(start / 16);
              }

              _createClass(CTR, [{
                key: "condensedMac",
                value: function condensedMac() {
                  if (this.mac) {
                    this.macs.push(this.mac);
                    this.mac = undefined;
                  }

                  var mac = Buffer.alloc(16);

                  for (var i = 0; i < this.macs.length; i++) {
                    for (var j = 0; j < 16; j++) {
                      mac[j] ^= this.macs[i][j];
                    }

                    this.aes.encryptECB(mac);
                  }

                  var macBuffer = Buffer.allocUnsafe(8);
                  macBuffer.writeInt32BE(mac.readInt32BE(0) ^ mac.readInt32BE(4), 0);
                  macBuffer.writeInt32BE(mac.readInt32BE(8) ^ mac.readInt32BE(12), 4);
                  return macBuffer;
                }
              }, {
                key: "encrypt",
                value: function encrypt(buffer) {
                  for (var i = 0; i < buffer.length; i += 16) {
                    var enc = this.aes.encryptECB(Buffer.from(this.ctr));

                    for (var j = 0; j < 16; j++) {
                      this.mac[j] ^= buffer[i + j];
                      buffer[i + j] ^= enc[j];
                    }

                    this.aes.encryptECB(this.mac);
                    this.incrementCTR();
                  }
                }
              }, {
                key: "decrypt",
                value: function decrypt(buffer) {
                  for (var i = 0; i < buffer.length; i += 16) {
                    var enc = this.aes.encryptECB(Buffer.from(this.ctr));

                    for (var j = 0; j < 16; j++) {
                      buffer[i + j] ^= enc[j];
                      this.mac[j] ^= buffer[i + j];
                    }

                    this.aes.encryptECB(this.mac);
                    this.incrementCTR();
                  }
                }
              }, {
                key: "incrementCTR",
                value: function incrementCTR() {
                  var cnt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

                  for (var _i2 = 0; _i2 < cnt; _i2++) {
                    this.checkMacBounding();
                  }

                  var buf = this.ctr;
                  var i = 15;
                  var mod;

                  while (cnt !== 0) {
                    mod = (cnt + buf[i]) % 256;
                    cnt = Math.floor((cnt + buf[i]) / 256);
                    buf[i] = mod;
                    i -= 1;
                    if (i < 0) i = 15;
                  }
                }
              }, {
                key: "checkMacBounding",
                value: function checkMacBounding() {
                  this.pos += 16;

                  if (this.pos >= this.posNext) {
                    this.macs.push(Buffer.from(this.mac));
                    this.nonce.copy(this.mac, 0);
                    this.nonce.copy(this.mac, 8);

                    if (this.increment < 1048576) {
                      this.increment += 131072;
                    }

                    this.posNext += this.increment;
                  }
                }
              }]);

              return CTR;
            }();

            function formatKey(key) {
              return typeof key === 'string' ? d64(key) : key;
            } // URL Safe Base64 encode/decode

            function e64(buffer) {
              return buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            }

            function d64(s) {
              return Buffer.from(s, 'base64');
            }
            function getCipher(key) {
              return new AES$1(unmergeKeyMac(key).slice(0, 16));
            }

            function megaEncrypt(key) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var start = options.start || 0;

              if (start !== 0) {
                throw Error('Encryption cannot start midstream otherwise MAC verification will fail.');
              }

              key = formatKey(key);

              if (!key) {
                key = secureRandom(24);
              }

              if (!(key instanceof Buffer)) {
                key = Buffer.from(key);
              }

              var stream = through_1(write, end);

              if (key.length !== 24) {
                return nextTick(function () {
                  stream.emit('error', Error('Wrong key length. Key must be 192bit.'));
                });
              }

              var aes = new AES$1(key.slice(0, 16));
              var ctr = new CTR(aes, key.slice(16), start);

              function write(d) {
                ctr.encrypt(d);
                this.emit('data', d);
              }

              function end() {
                var mac = ctr.condensedMac();
                stream.key = mergeKeyMac(key, mac);
                this.emit('end');
              }

              stream = streamCombiner(chunkSizeSafe(16), stream);
              return stream;
            }

            function megaDecrypt(key) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var start = options.start || 0;
              if (start !== 0) options.disableVerification = true;
              if (start % 16 !== 0) throw Error('start argument of megaDecrypt must be a multiple of 16');
              key = formatKey(key);
              var stream = through_1(write, end);
              var aes = getCipher(key);
              var ctr = new CTR(aes, key.slice(16), start);

              function write(d) {
                ctr.decrypt(d);
                this.emit('data', d);
              }

              function end() {
                var mac = ctr.condensedMac();

                if (!mac.equals(key.slice(24)) && !options.disableVerification) {
                  return this.emit('error', Error('MAC verification failed'));
                }

                this.emit('end');
              }

              stream = streamCombiner(chunkSizeSafe(16), stream);
              return stream;
            }

            function unmergeKeyMac(key) {
              var newKey = Buffer.alloc(32);
              key.copy(newKey);

              for (var i = 0; i < 16; i++) {
                newKey.writeUInt8(newKey.readUInt8(i) ^ newKey.readUInt8(16 + i, true), i);
              }

              return newKey;
            }

            function mergeKeyMac(key, mac) {
              var newKey = Buffer.alloc(32);
              key.copy(newKey);
              mac.copy(newKey, 24);

              for (var i = 0; i < 16; i++) {
                newKey.writeUInt8(newKey.readUInt8(i) ^ newKey.readUInt8(16 + i), i);
              }

              return newKey;
            }

            function constantTimeCompare(bufferA, bufferB) {
              if (bufferA.length !== bufferB.length) return false;
              var len = bufferA.length;
              var result = 0;

              for (var i = 0; i < len; i++) {
                result |= bufferA[i] ^ bufferB[i];
              }

              return result === 0;
            }

            /* RSA public key encryption/decryption
             * The following functions are (c) 2000 by John M Hanna and are
             * released under the terms of the Gnu Public License.
             * You must freely redistribute them with their source -- see the
             * GPL for details.
             *  -- Latest version found at http://sourceforge.net/projects/shop-js
             *
             * Modifications and GnuPG multi precision integer (mpi) conversion added
             * 2004 by Herbert Hanewinkel, www.haneWIN.de
             */
            // The original script assumes `this` to be a object (like `window`)
            // Then `this` was replaced with `globalState`

            var globalState = {}; // --- Arbitrary Precision Math ---
            // badd(a,b), bsub(a,b), bsqr(a), bmul(a,b)
            // bdiv(a,b), bmod(a,b), bexpmod(g,e,m), bmodexp(g,e,m)
            // bs is the shift, bm is the mask
            // set single precision bits to 28

            var bs = 28;
            var bx2 = 1 << bs;
            var bm = bx2 - 1;
            var bd = bs >> 1;
            var bdm = (1 << bd) - 1;
            var log2 = Math.log(2);

            function zeros(n) {
              var r = [];

              while (n-- > 0) {
                r[n] = 0;
              }

              return r;
            }

            function zclip(r) {
              var n = r.length;
              if (r[n - 1]) return r;

              while (n > 1 && r[n - 1] === 0) {
                n--;
              }

              return r.slice(0, n);
            } // returns bit length of integer x


            function nbits(x) {
              var n = 1;
              var t;

              if ((t = x >>> 16) !== 0) {
                x = t;
                n += 16;
              }

              if ((t = x >> 8) !== 0) {
                x = t;
                n += 8;
              }

              if ((t = x >> 4) !== 0) {
                x = t;
                n += 4;
              }

              if ((t = x >> 2) !== 0) {
                x = t;
                n += 2;
              }

              if ((t = x >> 1) !== 0) {
                x = t;
                n += 1;
              }

              return n;
            }

            function badd(a, b) {
              var al = a.length;
              var bl = b.length;
              if (al < bl) return badd(b, a);
              var r = [];
              var c = 0;
              var n = 0;

              for (; n < bl; n++) {
                c += a[n] + b[n];
                r[n] = c & bm;
                c >>>= bs;
              }

              for (; n < al; n++) {
                c += a[n];
                r[n] = c & bm;
                c >>>= bs;
              }

              if (c) r[n] = c;
              return r;
            }

            function bsub(a, b) {
              var al = a.length;
              var bl = b.length;
              if (bl > al) return [];

              if (bl === al) {
                if (b[bl - 1] > a[bl - 1]) return [];
                if (bl === 1) return [a[0] - b[0]];
              }

              var r = [];
              var c = 0;
              var n;

              for (n = 0; n < bl; n++) {
                c += a[n] - b[n];
                r[n] = c & bm;
                c >>= bs;
              }

              for (; n < al; n++) {
                c += a[n];
                r[n] = c & bm;
                c >>= bs;
              }

              if (c) return [];
              return zclip(r);
            }

            function ip(w, n, x, y, c) {
              var xl = x & bdm;
              var xh = x >> bd;
              var yl = y & bdm;
              var yh = y >> bd;
              var m = xh * yl + yh * xl;
              var l = xl * yl + ((m & bdm) << bd) + w[n] + c;
              w[n] = l & bm;
              c = xh * yh + (m >> bd) + (l >> bs);
              return c;
            } // Multiple-precision squaring, HAC Algorithm 14.16


            function bsqr(x) {
              var t = x.length;
              var n = 2 * t;
              var r = zeros(n);
              var c = 0;
              var i, j;

              for (i = 0; i < t; i++) {
                c = ip(r, 2 * i, x[i], x[i], 0);

                for (j = i + 1; j < t; j++) {
                  c = ip(r, i + j, 2 * x[j], x[i], c);
                }

                r[i + t] = c;
              }

              return zclip(r);
            } // Multiple-precision multiplication, HAC Algorithm 14.12


            function bmul(x, y) {
              var n = x.length;
              var t = y.length;
              var r = zeros(n + t - 1);
              var c, i, j;

              for (i = 0; i < t; i++) {
                c = 0;

                for (j = 0; j < n; j++) {
                  c = ip(r, i + j, x[j], y[i], c);
                }

                r[i + n] = c;
              }

              return zclip(r);
            }

            function toppart(x, start, len) {
              var n = 0;

              while (start >= 0 && len-- > 0) {
                n = n * bx2 + x[start--];
              }

              return n;
            } // Multiple-precision division, HAC Algorithm 14.20


            function bdiv(a, b) {
              var n = a.length - 1;
              var t = b.length - 1;
              var nmt = n - t;
              var x, y, qq, xx;
              var i; // trivial cases; a < b

              if (n < t || n === t && (a[n] < b[n] || n > 0 && a[n] === b[n] && a[n - 1] < b[n - 1])) {
                globalState.q = [0];
                globalState.mod = a;
                return globalState;
              } // trivial cases; q < 4


              if (n === t && toppart(a, t, 2) / toppart(b, t, 2) < 4) {
                x = a.concat();
                qq = 0;

                for (;;) {
                  xx = bsub(x, b);
                  if (xx.length === 0) break;
                  x = xx;
                  qq++;
                }

                globalState.q = [qq];
                globalState.mod = x;
                return globalState;
              } // normalize


              var shift2 = Math.floor(Math.log(b[t]) / log2) + 1;
              var shift = bs - shift2;
              x = a.concat();
              y = b.concat();

              if (shift) {
                for (i = t; i > 0; i--) {
                  y[i] = y[i] << shift & bm | y[i - 1] >> shift2;
                }

                y[0] = y[0] << shift & bm;

                if (x[n] & (bm << shift2 & bm)) {
                  x[++n] = 0;
                  nmt++;
                }

                for (i = n; i > 0; i--) {
                  x[i] = x[i] << shift & bm | x[i - 1] >> shift2;
                }

                x[0] = x[0] << shift & bm;
              }

              var x2;
              var q = zeros(nmt + 1);
              var y2 = zeros(nmt).concat(y);

              for (;;) {
                x2 = bsub(x, y2);
                if (x2.length === 0) break;
                q[nmt]++;
                x = x2;
              }

              var yt = y[t];
              var top = toppart(y, t, 2);
              var m;

              for (i = n; i > t; i--) {
                m = i - t - 1;

                if (i >= x.length) {
                  q[m] = 1;
                } else if (x[i] === yt) {
                  q[m] = bm;
                } else {
                  q[m] = Math.floor(toppart(x, i, 2) / yt);
                }

                var topx = toppart(x, i, 3);

                while (q[m] * top > topx) {
                  q[m]--;
                } // x-=q[m]*y*b^m


                y2 = y2.slice(1);
                x2 = bsub(x, bmul([q[m]], y2));

                if (x2.length === 0) {
                  q[m]--;
                  x2 = bsub(x, bmul([q[m]], y2));
                }

                x = x2;
              } // de-normalize


              if (shift) {
                for (i = 0; i < x.length - 1; i++) {
                  x[i] = x[i] >> shift | x[i + 1] << shift2 & bm;
                }

                x[x.length - 1] >>= shift;
              }

              globalState.q = zclip(q);
              globalState.mod = zclip(x);
              return globalState;
            } // returns the mod where m < 2^bd


            function simplemod(i, m) {
              var c = 0;
              var v;

              for (var n = i.length - 1; n >= 0; n--) {
                v = i[n];
                c = ((v >> bd) + (c << bd)) % m;
                c = ((v & bdm) + (c << bd)) % m;
              }

              return c;
            }

            function bmod(p, m) {
              if (m.length === 1) {
                if (p.length === 1) return [p[0] % m[0]];
                if (m[0] < bdm) return [simplemod(p, m[0])];
              }

              var r = bdiv(p, m);
              return r.mod;
            } // Barrett's modular reduction, HAC Algorithm 14.42


            function bmod2(x, m, mu) {
              var xl = x.length - (m.length << 1);
              if (xl > 0) return bmod2(x.slice(0, xl).concat(bmod2(x.slice(xl), m, mu)), m, mu);
              var ml1 = m.length + 1;
              var ml2 = m.length - 1;
              var rr;
              var q3 = bmul(x.slice(ml2), mu).slice(ml1);
              var r1 = x.slice(0, ml1);
              var r2 = bmul(q3, m).slice(0, ml1);
              var r = bsub(r1, r2);

              if (r.length === 0) {
                r1[ml1] = 1;
                r = bsub(r1, r2);
              }

              for (var n = 0;; n++) {
                rr = bsub(r, m);
                if (rr.length === 0) break;
                r = rr;
                if (n >= 3) return bmod2(r, m, mu);
              }

              return r;
            } // Modular exponentiation using Barrett reduction


            function bmodexp(g, e, m) {
              var a = g.concat();
              var l = e.length - 1;
              var n = m.length * 2;
              var mu = zeros(n + 1);
              mu[n] = 1;
              mu = bdiv(mu, m).q;
              n = nbits(e[l]) - 2;

              for (; l >= 0; l--) {
                for (; n >= 0; n -= 1) {
                  a = bmod2(bsqr(a), m, mu);
                  if (e[l] & 1 << n) a = bmod2(bmul(a, g), m, mu);
                }

                n = bs - 1;
              }

              return a;
            } // Compute m**d mod p*q for RSA private key operations.


            function RSAdecrypt(m, d, p, q, u) {
              var xp = bmodexp(bmod(m, p), bmod(d, bsub(p, [1])), p);
              var xq = bmodexp(bmod(m, q), bmod(d, bsub(q, [1])), q);
              var t = bsub(xq, xp);

              if (t.length === 0) {
                t = bsub(xp, xq);
                t = bmod(bmul(t, u), q);
                t = bsub(q, t);
              } else {
                t = bmod(bmul(t, u), q);
              }

              return badd(bmul(t, p), xp);
            } // -----------------------------------------------------------------
            // conversion functions: num array <-> multi precision integer (mpi)
            // mpi: 2 octets with length in bits + octets in big endian order


            function mpi2b(s) {
              var bn = 1;
              var r = [0];
              var rn = 0;
              var sb = 256;
              var sn = s.length;
              var c;
              if (sn < 2) return 0;
              var len = (sn - 2) * 8;
              var bits = s.charCodeAt(0) * 256 + s.charCodeAt(1);
              if (bits > len || bits < len - 8) return 0;

              for (var n = 0; n < len; n++) {
                if ((sb <<= 1) > 255) {
                  sb = 1;
                  c = s.charCodeAt(--sn);
                }

                if (bn > bm) {
                  bn = 1;
                  r[++rn] = 0;
                }

                if (c & sb) r[rn] |= bn;
                bn <<= 1;
              }

              return r;
            }

            function b2s(b) {
              var bn = 1;
              var bc = 0;
              var r = [0];
              var rb = 1;
              var rn = 0;
              var bits = b.length * bs;
              var rr = '';
              var n;

              for (n = 0; n < bits; n++) {
                if (b[bc] & bn) r[rn] |= rb;

                if ((rb <<= 1) > 255) {
                  rb = 1;
                  r[++rn] = 0;
                }

                if ((bn <<= 1) > bm) {
                  bn = 1;
                  bc++;
                }
              }

              while (rn >= 0 && r[rn] === 0) {
                rn--;
              }

              for (n = 0; n <= rn; n++) {
                rr = String.fromCharCode(r[n]) + rr;
              }

              return rr;
            }
            /**
             * cryptoDecodePrivKey
             * @public
             * @argv privk Buffer Private key
             * @return Private Key
             * @source https://github.com/meganz/webclient/blob/542d98ec61340b1e4fbf0dae0ae457c1bc5d49aa/js/crypto.js#L1448
             */


            function cryptoDecodePrivKey(privk) {
              var pubkey = []; // decompose private key

              for (var i = 0; i < 4; i++) {
                var l = (privk[0] * 256 + privk[1] + 7 >> 3) + 2;
                pubkey[i] = mpi2b(privk.toString('binary').substr(0, l));

                if (typeof pubkey[i] === 'number') {
                  if (i !== 4 || privk.length >= 16) return false;
                  break;
                }

                privk = privk.slice(l);
              }

              return pubkey;
            }
            /**
             * cryptoRsaDecrypt
             * @public
             * @argv ciphertext Buffer
             * @argv privkey Private Key
             * @return Buffer Decrypted plaintext
             * @source https://github.com/meganz/webclient/blob/4d95863d2cdbfb7652d16acdff8bae4b64056549/js/crypto.js#L1468
             */


            function cryptoRsaDecrypt(ciphertext, privkey) {
              var integerCiphertext = mpi2b(ciphertext.toString('binary'));
              var plaintext = b2s(RSAdecrypt(integerCiphertext, privkey[2], privkey[0], privkey[1], privkey[3]));
              return Buffer.from(plaintext, 'binary');
            }

            // should crash if both two are undefined, as this script assumes a browser environment

            var global$2 = typeof window !== 'undefined' ? window : self; // Browser Request
            //
            // Licensed under the Apache License, Version 2.0 (the "License")
            // you may not use this file except in compliance with the License.
            // You may obtain a copy of the License at
            //
            //     http://www.apache.org/licenses/LICENSE-2.0
            //
            // Unless required by applicable law or agreed to in writing, software
            // distributed under the License is distributed on an "AS IS" BASIS,
            // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            // See the License for the specific language governing permissions and
            // limitations under the License.

            request.log = {
              'trace': noop$1,
              'debug': noop$1,
              'info': noop$1,
              'warn': noop$1,
              'error': noop$1
            };
            var DEFAULT_TIMEOUT = 3 * 60 * 1000; // 3 minutes
            //
            // request
            //

            function request(options, callback) {
              if (!options) {
                throw Error('No options given');
              }

              var optionsOnResponse = options.onResponse; // Save this for later.

              if (typeof options === 'string') {
                options = {
                  'uri': options
                };
              } else {
                options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.
              }

              options.onResponse = optionsOnResponse; // And put it back.

              if (options.verbose) request.log = getLogger();

              if (options.url) {
                options.uri = options.url;
                delete options.url;
              }

              if (!options.uri && options.uri !== '') {
                throw Error('options.uri is a required argument');
              }

              if (typeof options.uri !== 'string') {
                throw Error('options.uri must be a string');
              }

              var unsupportedOptions = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];

              for (var i = 0; i < unsupportedOptions.length; i++) {
                if (options[unsupportedOptions[i]]) {
                  throw Error('options.' + unsupportedOptions[i] + ' is not supported');
                }
              }

              options.callback = callback || noop$1;
              options.method = options.method || 'GET';
              options.headers = options.headers || {};
              options.body = options.body || null;
              options.timeout = options.timeout || request.DEFAULT_TIMEOUT;

              if (options.headers.host) {
                throw Error('Options.headers.host is not supported');
              }

              if (options.json) {
                options.headers.accept = options.headers.accept || 'application/json';

                if (options.method !== 'GET') {
                  options.headers['content-type'] = 'application/json';
                }

                if (typeof options.json !== 'boolean') {
                  options.body = JSON.stringify(options.json);
                } else if (typeof options.body !== 'string') {
                  options.body = JSON.stringify(options.body);
                }
              } // BEGIN QS Hack


              var serialize = function serialize(obj) {
                var str = [];

                for (var p in obj) {
                  if (obj.hasOwnProperty(p)) {
                    str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
                  }
                }

                return str.join('&');
              };

              if (options.qs) {
                var qs = typeof options.qs === 'string' ? options.qs : serialize(options.qs);

                if (options.uri.indexOf('?') !== -1) {
                  // no get params
                  options.uri = options.uri + '&' + qs;
                } else {
                  // existing get params
                  options.uri = options.uri + '?' + qs;
                }
              } // END QS Hack
              // BEGIN FORM Hack


              var multipart = function multipart(obj) {
                // todo: support file type (useful?)
                var result = {};
                result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
                var lines = [];

                for (var p in obj) {
                  if (obj.hasOwnProperty(p)) {
                    lines.push('--' + result.boundry + '\n' + 'Content-Disposition: form-data; name="' + p + '"' + '\n' + '\n' + obj[p] + '\n');
                  }
                }

                lines.push('--' + result.boundry + '--');
                result.body = lines.join('');
                result.length = result.body.length;
                result.type = 'multipart/form-data; boundary=' + result.boundry;
                return result;
              };

              if (options.form) {
                if (typeof options.form === 'string') throw Error('form name unsupported');

                if (options.method === 'POST') {
                  var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
                  options.headers['content-type'] = encoding;

                  switch (encoding) {
                    case 'application/x-www-form-urlencoded':
                      options.body = serialize(options.form).replace(/%20/g, '+');
                      break;

                    case 'multipart/form-data':
                      var multi = multipart(options.form); // options.headers['content-length'] = multi.length

                      options.body = multi.body;
                      options.headers['content-type'] = multi.type;
                      break;

                    default:
                      throw Error('unsupported encoding:' + encoding);
                  }
                }
              } // END FORM Hack
              // If onResponse is boolean true, call back immediately when the response is known,
              // not when the full request is complete.


              options.onResponse = options.onResponse || noop$1;

              if (options.onResponse === true) {
                options.onResponse = callback;
                options.callback = noop$1;
              } // HTTP basic authentication


              if (!options.headers.authorization && options.auth) {
                options.headers.authorization = 'Basic ' + Buffer.from(options.auth.username + ':' + options.auth.password, 'utf-8').toString('base64');
              } // Only use fetch if it supports streams


              if (typeof fetch === 'function' && (typeof ReadableStream === 'function' || !global$2.XMLHttpRequest)) {
                return runFetch(options);
              }

              return runXhr(options);
            }

            var reqSeq = 0;

            function runXhr(options) {
              var xhr = new global$2.XMLHttpRequest();
              var isCors = isCrossDomain(options.uri);
              var supportsCors = ('withCredentials' in xhr);
              var timedOut = false;
              var offset = 0;
              reqSeq += 1;
              xhr.seq_id = reqSeq;
              xhr.id = reqSeq + ': ' + options.method + ' ' + options.uri;
              xhr._id = xhr.id; // I know I will type "_id" from habit all the time.

              if (isCors && !supportsCors) {
                var corsErr = new Error('Browser does not support cross-origin request: ' + options.uri);
                corsErr.cors = 'unsupported';
                return options.callback(corsErr, xhr);
              }

              xhr.timeoutTimer = setTimeout(tooLate, options.timeout);

              function tooLate() {
                timedOut = true;
                var er = new Error('ETIMEDOUT');
                er.code = 'ETIMEDOUT';
                er.duration = options.timeout;
                request.log.error('Timeout', {
                  'id': xhr._id,
                  'milliseconds': options.timeout
                });
                return options.callback(er, xhr);
              } // Some states can be skipped over, so remember what is still incomplete.


              var did = {
                response: false,
                loading: false,
                end: false
              };
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
              xhr.onreadystatechange = onStateChange;
              xhr.open(options.method, options.uri, true); // asynchronous

              if (isCors) {
                xhr.withCredentials = !!options.withCredentials;
              }

              xhr.send(options.body);
              var xhrStream = new Stream.Readable();
              xhrStream._read = noop$1;
              return xhrStream;

              function onStateChange(event) {
                if (timedOut) {
                  return request.log.debug('Ignoring timed out state change', {
                    state: xhr.readyState,
                    id: xhr.id
                  });
                }

                request.log.debug('State change', {
                  'state': xhr.readyState,
                  'id': xhr.id,
                  'timedOut': timedOut
                });

                if (xhr.readyState === global$2.XMLHttpRequest.OPENED) {
                  request.log.debug('Request started', {
                    id: xhr.id
                  });

                  for (var key in options.headers) {
                    xhr.setRequestHeader(key, options.headers[key]);
                  }
                } else if (xhr.readyState === global$2.XMLHttpRequest.HEADERS_RECEIVED) {
                  onResponse();
                } else if (xhr.readyState === global$2.XMLHttpRequest.LOADING) {
                  onResponse();
                  onLoading();
                } else if (xhr.readyState === global$2.XMLHttpRequest.DONE) {
                  onResponse();
                  onLoading();
                  onEnd();
                }
              }

              function onResponse() {
                if (did.response) {
                  return;
                }

                did.response = true;
                request.log.debug('Got response', {
                  id: xhr.id,
                  status: xhr.status
                });
                clearTimeout(xhr.timeoutTimer);
                xhr.statusCode = xhr.status; // Node request compatibility
                // Detect failed CORS requests.

                if (isCors && xhr.statusCode === 0) {
                  var _corsErr = new Error('CORS request rejected: ' + options.uri);

                  _corsErr.cors = 'rejected'; // Do not process this request further.

                  did.loading = true;
                  did.end = true;
                  xhrStream.emit('error', _corsErr);
                  return options.callback(_corsErr, xhr);
                }

                options.onResponse(null, xhr);
              }

              function onLoading() {
                if (xhr.response) {
                  var chunk = xhr.responseText.substr(offset);
                  offset += chunk.length;

                  if (chunk.length > 0) {
                    xhrStream.push(Buffer.from(chunk, 'ascii'));
                  }
                }

                if (did.loading) {
                  return;
                }

                did.loading = true;
                request.log.debug('Response body loading', {
                  id: xhr.id
                });
              }

              function onEnd() {
                if (did.end) {
                  return;
                }

                did.end = true;
                request.log.debug('Request done', {
                  id: xhr.id
                });
                xhrStream.push(null);
                xhr.body = xhr.responseText;

                if (options.json) {
                  try {
                    xhr.body = JSON.parse(xhr.responseText);
                  } catch (er) {
                    xhrStream.emit('error', er);
                    return options.callback(er, xhr);
                  }
                }

                options.callback(null, xhr, xhr.body);
              }
            } // request


            function runFetch(options) {
              var xhr = {};
              reqSeq += 1;
              xhr.seq_id = reqSeq;
              xhr.id = reqSeq + ': ' + options.method + ' ' + options.uri;
              xhr._id = xhr.id;
              reqSeq += 1;
              var fetchOptions = {};

              if (options.headers) {
                fetchOptions.headers = options.headers;
              }

              if (options.method) {
                fetchOptions.method = options.method;
              }

              if (options.body) {
                fetchOptions.body = options.body;
              }

              var fetchStream = new Stream.Readable();
              fetchStream._read = noop$1;
              global$2.fetch(options.uri || options.url, fetchOptions).then(function (response) {
                xhr.statusCode = xhr.status = response.status;
                fetchStream.emit('response', {
                  statusCode: response.status,
                  statusMessage: response.statusText,
                  headers: Array.from(response.headers).reduce(function (obj, _ref) {
                    var _ref2 = _slicedToArray(_ref, 2),
                        key = _ref2[0],
                        value = _ref2[1];

                    obj[key] = value;
                    return obj;
                  }, {})
                });

                if (options.callback) {
                  response.clone()[options.json ? 'json' : 'text']().then(function (data) {
                    return options.callback(null, xhr, data);
                  }).catch(function (error) {
                    return options.callback(error);
                  });
                }

                var bodyStream = response.body.getReader();
                readLoop();

                function readLoop() {
                  bodyStream.read().then(function (state) {
                    if (state.done) {
                      fetchStream.push(null);
                    } else {
                      fetchStream.push(Buffer.from(state.value));
                      readLoop();
                    }
                  });
                }
              }, function (error) {
                fetchStream.emit('error', error);
                options.callback(error);
              })
              .catch(function (error) { //ADDED Fansubs.cat
                return options.callback(error); //ADDED Fansubs.cat
              }); //ADDED Fansubs.cat;
              return fetchStream;
            } // fetch


            request.withCredentials = false;
            request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT; //
            // defaults
            //

            request.defaults = function (options, requester) {
              var def = function def(method) {
                var d = function d(params, callback) {
                  if (typeof params === 'string') {
                    params = {
                      'uri': params
                    };
                  } else {
                    params = JSON.parse(JSON.stringify(params));
                  }

                  for (var i in options) {
                    if (params[i] === undefined) params[i] = options[i];
                  }

                  return method(params, callback);
                };

                return d;
              };

              var de = def(request);
              de.get = def(request.get);
              de.post = def(request.post);
              de.put = def(request.put);
              de.head = def(request.head);
              return de;
            }; //
            // HTTP method shortcuts
            //


            var shortcuts = ['get', 'put', 'post', 'head'];
            shortcuts.forEach(function (shortcut) {
              var method = shortcut.toUpperCase();
              var func = shortcut.toLowerCase();

              request[func] = function (opts) {
                if (typeof opts === 'string') {
                  opts = {
                    'method': method,
                    'uri': opts
                  };
                } else {
                  opts = JSON.parse(JSON.stringify(opts));
                  opts.method = method;
                }

                var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
                return request.apply(this, args);
              };
            }); //
            // Utility
            //

            function noop$1() {}

            function getLogger() {
              var logger = {};
              var levels = ['trace', 'debug', 'info', 'warn', 'error'];
              var level, i;

              for (i = 0; i < levels.length; i++) {
                level = levels[i];
                logger[level] = noop$1;

                if (typeof console !== 'undefined' && console && console[level]) {
                  logger[level] = formatted(console, level);
                }
              }

              return logger;
            }

            function formatted(obj, method) {
              return formattedLogger;

              function formattedLogger(str, context) {
                if (_typeof(context) === 'object') {
                  str += ' ' + JSON.stringify(context);
                }

                return obj[method](str);
              }
            } // Return whether a URL is a cross-domain request.


            function isCrossDomain(url) {
              var rurl = /^([\w+.-]+:)(?:\/\/([^/?#:]*)(?::(\d+))?)?/; // jQuery #8138, IE may throw an exception when accessing
              // a field from global.location if document.domain has been set

              var ajaxLocation;

              try {
                ajaxLocation = global$2.location.href;
              } catch (e) {
                // Use the href attribute of an A element since IE will modify it given document.location
                ajaxLocation = document.createElement('a');
                ajaxLocation.href = '';
                ajaxLocation = ajaxLocation.href;
              }

              var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
              var parts = rurl.exec(url.toLowerCase());
              var result = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? 80 : 443)) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? 80 : 443))));
              return result;
            }

            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.


            // If obj.hasOwnProperty has been overridden, then calling
            // obj.hasOwnProperty(prop) will break.
            // See: https://github.com/joyent/node/issues/1707
            function hasOwnProperty$1(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var isArray$2 = Array.isArray || function (xs) {
              return Object.prototype.toString.call(xs) === '[object Array]';
            };
            function stringifyPrimitive(v) {
              switch (typeof v) {
                case 'string':
                  return v;

                case 'boolean':
                  return v ? 'true' : 'false';

                case 'number':
                  return isFinite(v) ? v : '';

                default:
                  return '';
              }
            }

            function stringify (obj, sep, eq, name) {
              sep = sep || '&';
              eq = eq || '=';
              if (obj === null) {
                obj = undefined;
              }

              if (typeof obj === 'object') {
                return map(objectKeys(obj), function(k) {
                  var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                  if (isArray$2(obj[k])) {
                    return map(obj[k], function(v) {
                      return ks + encodeURIComponent(stringifyPrimitive(v));
                    }).join(sep);
                  } else {
                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                  }
                }).join(sep);

              }

              if (!name) return '';
              return encodeURIComponent(stringifyPrimitive(name)) + eq +
                     encodeURIComponent(stringifyPrimitive(obj));
            }
            function map (xs, f) {
              if (xs.map) return xs.map(f);
              var res = [];
              for (var i = 0; i < xs.length; i++) {
                res.push(f(xs[i], i));
              }
              return res;
            }

            var objectKeys = Object.keys || function (obj) {
              var res = [];
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
              }
              return res;
            };

            function parse(qs, sep, eq, options) {
              sep = sep || '&';
              eq = eq || '=';
              var obj = {};

              if (typeof qs !== 'string' || qs.length === 0) {
                return obj;
              }

              var regexp = /\+/g;
              qs = qs.split(sep);

              var maxKeys = 1000;
              if (options && typeof options.maxKeys === 'number') {
                maxKeys = options.maxKeys;
              }

              var len = qs.length;
              // maxKeys <= 0 means that we should not limit keys count
              if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
              }

              for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, '%20'),
                    idx = x.indexOf(eq),
                    kstr, vstr, k, v;

                if (idx >= 0) {
                  kstr = x.substr(0, idx);
                  vstr = x.substr(idx + 1);
                } else {
                  kstr = x;
                  vstr = '';
                }

                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);

                if (!hasOwnProperty$1(obj, k)) {
                  obj[k] = v;
                } else if (isArray$2(obj[k])) {
                  obj[k].push(v);
                } else {
                  obj[k] = [obj[k], v];
                }
              }

              return obj;
            }var querystring = {
              encode: stringify,
              stringify: stringify,
              decode: parse,
              parse: parse
            }

            var MAX_RETRIES = 4;
            var ERRORS = {
              1: 'EINTERNAL (-1): An internal error has occurred. Please submit a bug report, detailing the exact circumstances in which this error occurred.',
              2: 'EARGS (-2): You have passed invalid arguments to this command.',
              3: 'EAGAIN (-3): A temporary congestion or server malfunction prevented your request from being processed. No data was altered. Retried ' + MAX_RETRIES + ' times.',
              4: 'ERATELIMIT (-4): You have exceeded your command weight per time quota. Please wait a few seconds, then try again (this should never happen in sane real-life applications).',
              5: 'EFAILED (-5): The upload failed. Please restart it from scratch.',
              6: 'ETOOMANY (-6): Too many concurrent IP addresses are accessing this upload target URL.',
              7: 'ERANGE (-7): The upload file packet is out of range or not starting and ending on a chunk boundary.',
              8: 'EEXPIRED (-8): The upload target URL you are trying to access has expired. Please request a fresh one.',
              9: 'ENOENT (-9): Object (typically, node or user) not found. Wrong password?',
              10: 'ECIRCULAR (-10): Circular linkage attempted',
              11: 'EACCESS (-11): Access violation (e.g., trying to write to a read-only share)',
              12: 'EEXIST (-12): Trying to create an object that already exists',
              13: 'EINCOMPLETE (-13): Trying to access an incomplete resource',
              14: 'EKEY (-14): A decryption operation failed (never returned by the API)',
              15: 'ESID (-15): Invalid or expired user session, please relogin',
              16: 'EBLOCKED (-16): User blocked',
              17: 'EOVERQUOTA (-17): Request over quota',
              18: 'ETEMPUNAVAIL (-18): Resource temporarily not available, please try again later'
            }; // The original MEGA package used https://g.api.mega.co.nz/

            var DEFAULT_GATEWAY = 'https://eu.api.mega.co.nz/';

            var API = /*#__PURE__*/function (_EventEmitter) {
              _inherits(API, _EventEmitter);

              var _super = _createSuper(API);

              function API(keepalive) {
                var _this;

                _classCallCheck(this, API);

                _this = _super.call(this);
                _this.keepalive = keepalive;
                _this.counterId = Math.random().toString().substr(2, 10);
                _this.gateway = DEFAULT_GATEWAY;
                _this.requestModule = request;
                return _this;
              }

              _createClass(API, [{
                key: "request",
                value: function request$$1(json, cb) {
                  var _this2 = this;

                  var retryno = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var qs = {
                    id: (this.counterId++).toString()
                  };

                  if (this.sid) {
                    qs.sid = this.sid;
                  }

                  if (_typeof(json._querystring) === 'object') {
                    Object.assign(qs, json._querystring);
                    delete json._querystring;
                  }

                  this.requestModule({
                    uri: "".concat(this.gateway, "cs"),
                    qs: qs,
                    method: 'POST',
                    json: [json],
                    gzip: true
                  }, function (err, req, resp) {
                    if (err) return cb(err);
                    if (!resp) return cb(Error('Empty response')); // Some error codes are returned as num, some as array with number.

                    if (resp.length) resp = resp[0];

                    if (!err && typeof resp === 'number' && resp < 0) {
                      if (resp === -3) {
                        if (retryno < MAX_RETRIES) {
                          return setTimeout(function () {
                            _this2.request(json, cb, retryno + 1);
                          }, Math.pow(2, retryno + 1) * 1e3);
                        }
                      }

                      err = Error(ERRORS[-resp]);
                    } else {
                      if (_this2.keepalive && resp && resp.sn) {
                        _this2.pull(resp.sn);
                      }
                    }

                    cb(err, resp);
                  });
                }
              }, {
                key: "pull",
                value: function pull(sn) {
                  var _this3 = this;

                  var retryno = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  this.sn = this.requestModule({
                    uri: "".concat(this.gateway, "sc"),
                    qs: {
                      sn: sn,
                      sid: this.sid
                    },
                    method: 'POST',
                    json: true,
                    body: "sc?".concat(querystring.stringify({
                      sn: sn
                    }))
                  }, function (err, req, resp) {
                    _this3.sn = undefined;

                    if (!err && typeof resp === 'number' && resp < 0) {
                      if (resp === -3) {
                        if (retryno < MAX_RETRIES) {
                          return setTimeout(function () {
                            _this3.pull(sn, retryno + 1);
                          }, Math.pow(2, retryno + 1) * 1e3);
                        }
                      }

                      err = Error(ERRORS[-resp]);
                    }

                    if (err) throw err;

                    if (resp.w) {
                      _this3.wait(resp.w, sn);
                    } else if (resp.sn) {
                      if (resp.a) {
                        _this3.emit('sc', resp.a);
                      }

                      _this3.pull(resp.sn);
                    }
                  });
                }
              }, {
                key: "wait",
                value: function wait(url, sn) {
                  var _this4 = this;

                  this.sn = this.requestModule({
                    uri: url,
                    method: 'POST'
                  }, function (err, req, body) {
                    _this4.sn = undefined;
                    if (err) throw Error('mega server wait req failed');

                    _this4.pull(sn);
                  });
                }
              }, {
                key: "close",
                value: function close() {
                  if (this.sn) this.sn.abort();
                }
              }]);

              return API;
            }(EventEmitter);

            var util$2 = ( util$1 && util ) || util$1;

            var Stream$1 = require$$0.Stream;


            var delayed_stream = DelayedStream;
            function DelayedStream() {
              this.source = null;
              this.dataSize = 0;
              this.maxDataSize = 1024 * 1024;
              this.pauseStream = true;

              this._maxDataSizeExceeded = false;
              this._released = false;
              this._bufferedEvents = [];
            }
            util$2.inherits(DelayedStream, Stream$1);

            DelayedStream.create = function(source, options) {
              var delayedStream = new this();

              options = options || {};
              for (var option in options) {
                delayedStream[option] = options[option];
              }

              delayedStream.source = source;

              var realEmit = source.emit;
              source.emit = function() {
                delayedStream._handleEmit(arguments);
                return realEmit.apply(source, arguments);
              };

              source.on('error', function() {});
              if (delayedStream.pauseStream) {
                source.pause();
              }

              return delayedStream;
            };

            Object.defineProperty(DelayedStream.prototype, 'readable', {
              configurable: true,
              enumerable: true,
              get: function() {
                return this.source.readable;
              }
            });

            DelayedStream.prototype.setEncoding = function() {
              return this.source.setEncoding.apply(this.source, arguments);
            };

            DelayedStream.prototype.resume = function() {
              if (!this._released) {
                this.release();
              }

              this.source.resume();
            };

            DelayedStream.prototype.pause = function() {
              this.source.pause();
            };

            DelayedStream.prototype.release = function() {
              this._released = true;

              this._bufferedEvents.forEach(function(args) {
                this.emit.apply(this, args);
              }.bind(this));
              this._bufferedEvents = [];
            };

            DelayedStream.prototype.pipe = function() {
              var r = Stream$1.prototype.pipe.apply(this, arguments);
              this.resume();
              return r;
            };

            DelayedStream.prototype._handleEmit = function(args) {
              if (this._released) {
                this.emit.apply(this, args);
                return;
              }

              if (args[0] === 'data') {
                this.dataSize += args[1].length;
                this._checkIfMaxDataSizeExceeded();
              }

              this._bufferedEvents.push(args);
            };

            DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
              if (this._maxDataSizeExceeded) {
                return;
              }

              if (this.dataSize <= this.maxDataSize) {
                return;
              }

              this._maxDataSizeExceeded = true;
              var message =
                'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
              this.emit('error', new Error(message));
            };

            var delayed_stream$1 = /*#__PURE__*/Object.freeze({
                        default: delayed_stream,
                        __moduleExports: delayed_stream
            });

            var DelayedStream$1 = ( delayed_stream$1 && delayed_stream ) || delayed_stream$1;

            var Stream$2 = require$$0.Stream;


            var combined_stream = CombinedStream;
            function CombinedStream() {
              this.writable = false;
              this.readable = true;
              this.dataSize = 0;
              this.maxDataSize = 2 * 1024 * 1024;
              this.pauseStreams = true;

              this._released = false;
              this._streams = [];
              this._currentStream = null;
              this._insideLoop = false;
              this._pendingNext = false;
            }
            util$2.inherits(CombinedStream, Stream$2);

            CombinedStream.create = function(options) {
              var combinedStream = new this();

              options = options || {};
              for (var option in options) {
                combinedStream[option] = options[option];
              }

              return combinedStream;
            };

            CombinedStream.isStreamLike = function(stream) {
              return (typeof stream !== 'function')
                && (typeof stream !== 'string')
                && (typeof stream !== 'boolean')
                && (typeof stream !== 'number')
                && (!isBuffer(stream));
            };

            CombinedStream.prototype.append = function(stream) {
              var isStreamLike = CombinedStream.isStreamLike(stream);

              if (isStreamLike) {
                if (!(stream instanceof DelayedStream$1)) {
                  var newStream = DelayedStream$1.create(stream, {
                    maxDataSize: Infinity,
                    pauseStream: this.pauseStreams,
                  });
                  stream.on('data', this._checkDataSize.bind(this));
                  stream = newStream;
                }

                this._handleErrors(stream);

                if (this.pauseStreams) {
                  stream.pause();
                }
              }

              this._streams.push(stream);
              return this;
            };

            CombinedStream.prototype.pipe = function(dest, options) {
              Stream$2.prototype.pipe.call(this, dest, options);
              this.resume();
              return dest;
            };

            CombinedStream.prototype._getNext = function() {
              this._currentStream = null;

              if (this._insideLoop) {
                this._pendingNext = true;
                return; // defer call
              }

              this._insideLoop = true;
              try {
                do {
                  this._pendingNext = false;
                  this._realGetNext();
                } while (this._pendingNext);
              } finally {
                this._insideLoop = false;
              }
            };

            CombinedStream.prototype._realGetNext = function() {
              var stream = this._streams.shift();


              if (typeof stream == 'undefined') {
                this.end();
                return;
              }

              if (typeof stream !== 'function') {
                this._pipeNext(stream);
                return;
              }

              var getStream = stream;
              getStream(function(stream) {
                var isStreamLike = CombinedStream.isStreamLike(stream);
                if (isStreamLike) {
                  stream.on('data', this._checkDataSize.bind(this));
                  this._handleErrors(stream);
                }

                this._pipeNext(stream);
              }.bind(this));
            };

            CombinedStream.prototype._pipeNext = function(stream) {
              this._currentStream = stream;

              var isStreamLike = CombinedStream.isStreamLike(stream);
              if (isStreamLike) {
                stream.on('end', this._getNext.bind(this));
                stream.pipe(this, {end: false});
                return;
              }

              var value = stream;
              this.write(value);
              this._getNext();
            };

            CombinedStream.prototype._handleErrors = function(stream) {
              var self = this;
              stream.on('error', function(err) {
                self._emitError(err);
              });
            };

            CombinedStream.prototype.write = function(data) {
              this.emit('data', data);
            };

            CombinedStream.prototype.pause = function() {
              if (!this.pauseStreams) {
                return;
              }

              if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
              this.emit('pause');
            };

            CombinedStream.prototype.resume = function() {
              if (!this._released) {
                this._released = true;
                this.writable = true;
                this._getNext();
              }

              if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
              this.emit('resume');
            };

            CombinedStream.prototype.end = function() {
              this._reset();
              this.emit('end');
            };

            CombinedStream.prototype.destroy = function() {
              this._reset();
              this.emit('close');
            };

            CombinedStream.prototype._reset = function() {
              this.writable = false;
              this._streams = [];
              this._currentStream = null;
            };

            CombinedStream.prototype._checkDataSize = function() {
              this._updateDataSize();
              if (this.dataSize <= this.maxDataSize) {
                return;
              }

              var message =
                'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
              this._emitError(new Error(message));
            };

            CombinedStream.prototype._updateDataSize = function() {
              this.dataSize = 0;

              var self = this;
              this._streams.forEach(function(stream) {
                if (!stream.dataSize) {
                  return;
                }

                self.dataSize += stream.dataSize;
              });

              if (this._currentStream && this._currentStream.dataSize) {
                this.dataSize += this._currentStream.dataSize;
              }
            };

            CombinedStream.prototype._emitError = function(err) {
              this._reset();
              this.emit('error', err);
            };

            /*! https://mths.be/punycode v1.4.1 by @mathias */


            /** Highest positive signed 32-bit float value */
            var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

            /** Bootstring parameters */
            var base = 36;
            var tMin = 1;
            var tMax = 26;
            var skew = 38;
            var damp = 700;
            var initialBias = 72;
            var initialN = 128; // 0x80
            var delimiter = '-'; // '\x2D'
            var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
            var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

            /** Error messages */
            var errors = {
              'overflow': 'Overflow: input needs wider integers to process',
              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
              'invalid-input': 'Invalid input'
            };

            /** Convenience shortcuts */
            var baseMinusTMin = base - tMin;
            var floor = Math.floor;
            var stringFromCharCode = String.fromCharCode;

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw new RangeError(errors[type]);
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map$1(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@');
              var result = '';
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E');
              var labels = string.split('.');
              var encoded = map$1(labels, fn).join('.');
              return result + encoded;
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);

              // Cache the length
              inputLength = input.length;

              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }

              handledCPCount = basicLength = output.length;

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base; /* no condition */ ; k += base) {
                      t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(
                        stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                      );
                      q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }

                ++delta;
                ++n;

              }
              return output.join('');
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ?
                  'xn--' + encode(string) :
                  string;
              });
            }

            // Copyright Joyent, Inc. and other Node contributors.
            function Url() {
              this.protocol = null;
              this.slashes = null;
              this.auth = null;
              this.host = null;
              this.port = null;
              this.hostname = null;
              this.hash = null;
              this.search = null;
              this.query = null;
              this.pathname = null;
              this.path = null;
              this.href = null;
            }

            // Reference: RFC 3986, RFC 1808, RFC 2396

            // define these here so at least they only have to be
            // compiled once on the first module load.
            var protocolPattern = /^([a-z0-9.+-]+:)/i,
              portPattern = /:[0-9]*$/,

              // Special case for a simple path URL
              simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

              // RFC 2396: characters reserved for delimiting URLs.
              // We actually just auto-escape these.
              delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

              // RFC 2396: characters not allowed for various reasons.
              unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

              // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
              autoEscape = ['\''].concat(unwise),
              // Characters that are never ever allowed in a hostname.
              // Note that any invalid chars are also handled, but these
              // are the ones that are *expected* to be seen, so we fast-path
              // them.
              nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
              hostEndingChars = ['/', '?', '#'],
              hostnameMaxLen = 255,
              hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
              hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
              // protocols that can allow "unsafe" and "unwise" chars.
              unsafeProtocol = {
                'javascript': true,
                'javascript:': true
              },
              // protocols that never have a hostname.
              hostlessProtocol = {
                'javascript': true,
                'javascript:': true
              },
              // protocols that always contain a // bit.
              slashedProtocol = {
                'http': true,
                'https': true,
                'ftp': true,
                'gopher': true,
                'file': true,
                'http:': true,
                'https:': true,
                'ftp:': true,
                'gopher:': true,
                'file:': true
              };

            function urlParse(url, parseQueryString, slashesDenoteHost) {
              if (url && isObject(url) && url instanceof Url) return url;

              var u = new Url;
              u.parse(url, parseQueryString, slashesDenoteHost);
              return u;
            }
            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
              return parse$1(this, url, parseQueryString, slashesDenoteHost);
            };

            function parse$1(self, url, parseQueryString, slashesDenoteHost) {
              if (!isString(url)) {
                throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
              }

              // Copy chrome, IE, opera backslash-handling behavior.
              // Back slashes before the query string get converted to forward slashes
              // See: https://code.google.com/p/chromium/issues/detail?id=25916
              var queryIndex = url.indexOf('?'),
                splitter =
                (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
                uSplit = url.split(splitter),
                slashRegex = /\\/g;
              uSplit[0] = uSplit[0].replace(slashRegex, '/');
              url = uSplit.join(splitter);

              var rest = url;

              // trim before proceeding.
              // This is to support parse stuff like "  http://foo.com  \n"
              rest = rest.trim();

              if (!slashesDenoteHost && url.split('#').length === 1) {
                // Try fast path regexp
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                  self.path = rest;
                  self.href = rest;
                  self.pathname = simplePath[1];
                  if (simplePath[2]) {
                    self.search = simplePath[2];
                    if (parseQueryString) {
                      self.query = parse(self.search.substr(1));
                    } else {
                      self.query = self.search.substr(1);
                    }
                  } else if (parseQueryString) {
                    self.search = '';
                    self.query = {};
                  }
                  return self;
                }
              }

              var proto = protocolPattern.exec(rest);
              if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                self.protocol = lowerProto;
                rest = rest.substr(proto.length);
              }

              // figure out if it's got a host
              // user@server is *always* interpreted as a hostname, and url
              // resolution will treat //foo/bar as host=foo,path=bar because that's
              // how the browser resolves relative URLs.
              if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === '//';
                if (slashes && !(proto && hostlessProtocol[proto])) {
                  rest = rest.substr(2);
                  self.slashes = true;
                }
              }
              var i, hec, l, p;
              if (!hostlessProtocol[proto] &&
                (slashes || (proto && !slashedProtocol[proto]))) {

                // there's a hostname.
                // the first instance of /, ?, ;, or # ends the host.
                //
                // If there is an @ in the hostname, then non-host chars *are* allowed
                // to the left of the last @ sign, unless some host-ending character
                // comes *before* the @-sign.
                // URLs are obnoxious.
                //
                // ex:
                // http://a@b@c/ => user:a@b host:c
                // http://a@b?@c => user:a host:c path:/?@c

                // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                // Review our test case against browsers more comprehensively.

                // find the first instance of any hostEndingChars
                var hostEnd = -1;
                for (i = 0; i < hostEndingChars.length; i++) {
                  hec = rest.indexOf(hostEndingChars[i]);
                  if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                    hostEnd = hec;
                }

                // at this point, either we have an explicit point where the
                // auth portion cannot go past, or the last @ char is the decider.
                var auth, atSign;
                if (hostEnd === -1) {
                  // atSign can be anywhere.
                  atSign = rest.lastIndexOf('@');
                } else {
                  // atSign must be in auth portion.
                  // http://a@b/c@d => host:b auth:a path:/c@d
                  atSign = rest.lastIndexOf('@', hostEnd);
                }

                // Now we have a portion which is definitely the auth.
                // Pull that off.
                if (atSign !== -1) {
                  auth = rest.slice(0, atSign);
                  rest = rest.slice(atSign + 1);
                  self.auth = decodeURIComponent(auth);
                }

                // the host is the remaining to the left of the first non-host char
                hostEnd = -1;
                for (i = 0; i < nonHostChars.length; i++) {
                  hec = rest.indexOf(nonHostChars[i]);
                  if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                    hostEnd = hec;
                }
                // if we still have not hit it, then the entire thing is a host.
                if (hostEnd === -1)
                  hostEnd = rest.length;

                self.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);

                // pull out port.
                parseHost(self);

                // we've indicated that there is a hostname,
                // so even if it's empty, it has to be present.
                self.hostname = self.hostname || '';

                // if hostname begins with [ and ends with ]
                // assume that it's an IPv6 address.
                var ipv6Hostname = self.hostname[0] === '[' &&
                  self.hostname[self.hostname.length - 1] === ']';

                // validate a little.
                if (!ipv6Hostname) {
                  var hostparts = self.hostname.split(/\./);
                  for (i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) continue;
                    if (!part.match(hostnamePartPattern)) {
                      var newpart = '';
                      for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                          // we replace non-ASCII char with a temporary placeholder
                          // we need this to make sure size of hostname is not
                          // broken by replacing non-ASCII by nothing
                          newpart += 'x';
                        } else {
                          newpart += part[j];
                        }
                      }
                      // we test again with ASCII char only
                      if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                          validParts.push(bit[1]);
                          notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                          rest = '/' + notHost.join('.') + rest;
                        }
                        self.hostname = validParts.join('.');
                        break;
                      }
                    }
                  }
                }

                if (self.hostname.length > hostnameMaxLen) {
                  self.hostname = '';
                } else {
                  // hostnames are always lower case.
                  self.hostname = self.hostname.toLowerCase();
                }

                if (!ipv6Hostname) {
                  // IDNA Support: Returns a punycoded representation of "domain".
                  // It only converts parts of the domain name that
                  // have non-ASCII characters, i.e. it doesn't matter if
                  // you call it with a domain that already is ASCII-only.
                  self.hostname = toASCII(self.hostname);
                }

                p = self.port ? ':' + self.port : '';
                var h = self.hostname || '';
                self.host = h + p;
                self.href += self.host;

                // strip [ and ] from the hostname
                // the host field still retains them, though
                if (ipv6Hostname) {
                  self.hostname = self.hostname.substr(1, self.hostname.length - 2);
                  if (rest[0] !== '/') {
                    rest = '/' + rest;
                  }
                }
              }

              // now rest is set to the post-host stuff.
              // chop off any delim chars.
              if (!unsafeProtocol[lowerProto]) {

                // First, make 100% sure that any "autoEscape" chars get
                // escaped, even if encodeURIComponent doesn't think they
                // need to be.
                for (i = 0, l = autoEscape.length; i < l; i++) {
                  var ae = autoEscape[i];
                  if (rest.indexOf(ae) === -1)
                    continue;
                  var esc = encodeURIComponent(ae);
                  if (esc === ae) {
                    esc = escape(ae);
                  }
                  rest = rest.split(ae).join(esc);
                }
              }


              // chop off from the tail first.
              var hash = rest.indexOf('#');
              if (hash !== -1) {
                // got a fragment string.
                self.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
              }
              var qm = rest.indexOf('?');
              if (qm !== -1) {
                self.search = rest.substr(qm);
                self.query = rest.substr(qm + 1);
                if (parseQueryString) {
                  self.query = parse(self.query);
                }
                rest = rest.slice(0, qm);
              } else if (parseQueryString) {
                // no query string, but parseQueryString still requested
                self.search = '';
                self.query = {};
              }
              if (rest) self.pathname = rest;
              if (slashedProtocol[lowerProto] &&
                self.hostname && !self.pathname) {
                self.pathname = '/';
              }

              //to support http.request
              if (self.pathname || self.search) {
                p = self.pathname || '';
                var s = self.search || '';
                self.path = p + s;
              }

              // finally, reconstruct the href based on what has been validated.
              self.href = format$1(self);
              return self;
            }

            function format$1(self) {
              var auth = self.auth || '';
              if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ':');
                auth += '@';
              }

              var protocol = self.protocol || '',
                pathname = self.pathname || '',
                hash = self.hash || '',
                host = false,
                query = '';

              if (self.host) {
                host = auth + self.host;
              } else if (self.hostname) {
                host = auth + (self.hostname.indexOf(':') === -1 ?
                  self.hostname :
                  '[' + this.hostname + ']');
                if (self.port) {
                  host += ':' + self.port;
                }
              }

              if (self.query &&
                isObject(self.query) &&
                Object.keys(self.query).length) {
                query = stringify(self.query);
              }

              var search = self.search || (query && ('?' + query)) || '';

              if (protocol && protocol.substr(-1) !== ':') protocol += ':';

              // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
              // unless they had them to begin with.
              if (self.slashes ||
                (!protocol || slashedProtocol[protocol]) && host !== false) {
                host = '//' + (host || '');
                if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
              } else if (!host) {
                host = '';
              }

              if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
              if (search && search.charAt(0) !== '?') search = '?' + search;

              pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
              });
              search = search.replace('#', '%23');

              return protocol + host + pathname + search + hash;
            }

            Url.prototype.format = function() {
              return format$1(this);
            };

            Url.prototype.resolve = function(relative) {
              return this.resolveObject(urlParse(relative, false, true)).format();
            };

            Url.prototype.resolveObject = function(relative) {
              if (isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
              }

              var result = new Url();
              var tkeys = Object.keys(this);
              for (var tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
              }

              // hash is always overridden, no matter what.
              // even href="" will remove it.
              result.hash = relative.hash;

              // if the relative url is empty, then there's nothing left to do here.
              if (relative.href === '') {
                result.href = result.format();
                return result;
              }

              // hrefs like //foo/bar always cut to the protocol.
              if (relative.slashes && !relative.protocol) {
                // take everything except the protocol from relative
                var rkeys = Object.keys(relative);
                for (var rk = 0; rk < rkeys.length; rk++) {
                  var rkey = rkeys[rk];
                  if (rkey !== 'protocol')
                    result[rkey] = relative[rkey];
                }

                //urlParse appends trailing / to urls like http://www.example.com
                if (slashedProtocol[result.protocol] &&
                  result.hostname && !result.pathname) {
                  result.path = result.pathname = '/';
                }

                result.href = result.format();
                return result;
              }
              var relPath;
              if (relative.protocol && relative.protocol !== result.protocol) {
                // if it's a known url protocol, then changing
                // the protocol does weird things
                // first, if it's not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that's known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashedProtocol[relative.protocol]) {
                  var keys = Object.keys(relative);
                  for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                  }
                  result.href = result.format();
                  return result;
                }

                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                  relPath = (relative.pathname || '').split('/');
                  while (relPath.length && !(relative.host = relPath.shift()));
                  if (!relative.host) relative.host = '';
                  if (!relative.hostname) relative.hostname = '';
                  if (relPath[0] !== '') relPath.unshift('');
                  if (relPath.length < 2) relPath.unshift('');
                  result.pathname = relPath.join('/');
                } else {
                  result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || '';
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                // to support http.request
                if (result.pathname || result.search) {
                  var p = result.pathname || '';
                  var s = result.search || '';
                  result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
              }

              var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
                isRelAbs = (
                  relative.host ||
                  relative.pathname && relative.pathname.charAt(0) === '/'
                ),
                mustEndAbs = (isRelAbs || isSourceAbs ||
                  (result.host && relative.pathname)),
                removeAllDots = mustEndAbs,
                srcPath = result.pathname && result.pathname.split('/') || [],
                psychotic = result.protocol && !slashedProtocol[result.protocol];
              relPath = relative.pathname && relative.pathname.split('/') || [];
              // if the url is a non-slashed url, then relative
              // links like ../.. should be able
              // to crawl up to the hostname, as well.  This is strange.
              // result.protocol has already been set by now.
              // Later on, put the first path part into the host field.
              if (psychotic) {
                result.hostname = '';
                result.port = null;
                if (result.host) {
                  if (srcPath[0] === '') srcPath[0] = result.host;
                  else srcPath.unshift(result.host);
                }
                result.host = '';
                if (relative.protocol) {
                  relative.hostname = null;
                  relative.port = null;
                  if (relative.host) {
                    if (relPath[0] === '') relPath[0] = relative.host;
                    else relPath.unshift(relative.host);
                  }
                  relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
              }
              var authInHost;
              if (isRelAbs) {
                // it's absolute.
                result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
                result.hostname = (relative.hostname || relative.hostname === '') ?
                  relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
                // fall through to the dot-handling below.
              } else if (relPath.length) {
                // it's relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
              } else if (!isNullOrUndefined(relative.search)) {
                // just pull out the search.
                // like href='?foo'.
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                  result.hostname = result.host = srcPath.shift();
                  //occationaly the auth can get stuck only in host
                  //this especially happens in cases like
                  //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                  authInHost = result.host && result.host.indexOf('@') > 0 ?
                    result.host.split('@') : false;
                  if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                  }
                }
                result.search = relative.search;
                result.query = relative.query;
                //to support http.request
                if (!isNull(result.pathname) || !isNull(result.search)) {
                  result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
                }
                result.href = result.format();
                return result;
              }

              if (!srcPath.length) {
                // no path at all.  easy.
                // we've already handled the other stuff above.
                result.pathname = null;
                //to support http.request
                if (result.search) {
                  result.path = '/' + result.search;
                } else {
                  result.path = null;
                }
                result.href = result.format();
                return result;
              }

              // if a url ENDs in . or .., then it must get a trailing slash.
              // however, if it ends in anything else non-slashy,
              // then it must NOT get a trailing slash.
              var last = srcPath.slice(-1)[0];
              var hasTrailingSlash = (
                (result.host || relative.host || srcPath.length > 1) &&
                (last === '.' || last === '..') || last === '');

              // strip single dots, resolve double dots to parent dir
              // if the path tries to go above the root, `up` ends up > 0
              var up = 0;
              for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last === '.') {
                  srcPath.splice(i, 1);
                } else if (last === '..') {
                  srcPath.splice(i, 1);
                  up++;
                } else if (up) {
                  srcPath.splice(i, 1);
                  up--;
                }
              }

              // if the path is allowed to go above the root, restore leading ..s
              if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                  srcPath.unshift('..');
                }
              }

              if (mustEndAbs && srcPath[0] !== '' &&
                (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                srcPath.unshift('');
              }

              if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
                srcPath.push('');
              }

              var isAbsolute = srcPath[0] === '' ||
                (srcPath[0] && srcPath[0].charAt(0) === '/');

              // put the host back
              if (psychotic) {
                result.hostname = result.host = isAbsolute ? '' :
                  srcPath.length ? srcPath.shift() : '';
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                authInHost = result.host && result.host.indexOf('@') > 0 ?
                  result.host.split('@') : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }

              mustEndAbs = mustEndAbs || (result.host && srcPath.length);

              if (mustEndAbs && !isAbsolute) {
                srcPath.unshift('');
              }

              if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
              } else {
                result.pathname = srcPath.join('/');
              }

              //to support request.http
              if (!isNull(result.pathname) || !isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
              }
              result.auth = relative.auth || result.auth;
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            };

            Url.prototype.parseHost = function() {
              return parseHost(this);
            };

            function parseHost(self) {
              var host = self.host;
              var port = portPattern.exec(host);
              if (port) {
                port = port[0];
                if (port !== ':') {
                  self.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
              }
              if (host) self.hostname = host;
            }

            var Transform$1 = require$$0.Transform;

            function Skip(options) {
            	// allow use without new
            	if (!(this instanceof Skip)) {
            		return new Skip(options);
            	}

            	this._toSkip = options.skip;

            	// init Transform
            	Transform$1.call(this, options);
            }
            util$2.inherits(Skip, Transform$1);

            Skip.prototype._transform = function (chunk, enc, cb) {
            	if (this._toSkip == 0) this.push(chunk);
            	else if (this._toSkip > chunk.length) {
            		this._toSkip -= chunk.length;
            	} else {
            		if (this._toSkip !== chunk.length) this.push(chunk.slice(this._toSkip));
            		this._toSkip = 0;
            	}
            	cb();
            };

            var streamSkip = Skip;

            var notLoggedApi;

            var File = /*#__PURE__*/function (_EventEmitter) {
              _inherits(File, _EventEmitter);

              var _super = _createSuper(File);

              function File(opt) {
                var _this;

                _classCallCheck(this, File);

                _this = _super.call(this);

                _this.checkConstructorArgument(opt.downloadId);

                _this.checkConstructorArgument(opt.key);

                _this.checkConstructorArgument(opt.loadedFile);

                _this.downloadId = opt.downloadId;
                _this.key = opt.key ? formatKey(opt.key) : null;
                _this.type = opt.directory ? 1 : 0;
                _this.directory = !!opt.directory; // Create a new API object on demand

                if (!notLoggedApi) notLoggedApi = new API(false);
                _this.api = notLoggedApi;
                _this.loadedFile = opt.loadedFile;
                return _this;
              }

              _createClass(File, [{
                key: "createdAt",
                get: function get() {
                  if (typeof this.timestamp !== 'undefined') {
                    return this.timestamp * 1000;
                  }
                }
              }, {
                key: "checkConstructorArgument",
                value: function checkConstructorArgument(value) {
                  // If a string was passed then check if it's not empty and
                  // contains only base64 valid characters
                  if (typeof value === 'string' && !/^[\w-]+$/.test(value)) {
                    throw Error("Invalid argument: \"".concat(value, "\""));
                  }
                }
              }, {
                key: "loadMetadata",
                value: function loadMetadata(aes, opt) {
                  this.size = opt.s || 0;
                  this.timestamp = opt.ts || 0;
                  this.type = opt.t;
                  this.directory = !!opt.t;
                  this.owner = opt.u;
                  this.name = null;
                  if (!aes || !opt.k) return;
                  var parts = opt.k.split(':');
                  this.key = formatKey(parts[parts.length - 1]);
                  aes.decryptECB(this.key);

                  if (opt.a) {
                    this.decryptAttributes(opt.a);
                  }
                }
              }, {
                key: "decryptAttributes",
                value: function decryptAttributes(at) {
                  if (!this.key) return this;
                  at = d64(at);
                  getCipher(this.key).decryptCBC(at);
                  var unpackedAttribtes = File.unpackAttributes(at);

                  if (unpackedAttribtes) {
                    this.parseAttributes(unpackedAttribtes);
                  }

                  return this;
                }
              }, {
                key: "parseAttributes",
                value: function parseAttributes(at) {
                  this.attributes = at;
                  this.name = at.n;
                  this.label = LABEL_NAMES[at.lbl || 0];
                  this.favorited = !!at.fav;
                }
              }, {
                key: "loadAttributes",
                value: function loadAttributes(cb) {
                  var _this2 = this;

                  if (typeof cb !== 'function') {
                    cb = function cb(err) {
                      if (err) throw err;
                    };
                  } // todo: nodeId version ('n')


                  var req = this.directory ? {
                    a: 'f',
                    c: 1,
                    ca: 1,
                    r: 1,
                    _querystring: {
                      n: this.downloadId
                    }
                  } : {
                    a: 'g',
                    p: this.downloadId
                  };
                  this.api.request(req, function (err, response) {
                    if (err) return cb(err);

                    if (_this2.directory) {
                      var filesMap = Object.create(null);
                      var nodes = response.f;
                      var folder = nodes.find(function (node) {
                        return node.k && // the root folder is the one which "n" equals the first part of "k"
                        node.h === node.k.split(':')[0];
                      });
                      var aes = _this2.key ? new AES$1(_this2.key) : null;
                      _this2.nodeId = folder.h;
                      _this2.timestamp = folder.ts;
                      filesMap[folder.h] = _this2;

                      var _iterator = _createForOfIteratorHelper(nodes),
                          _step;

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          var file = _step.value;
                          if (file === folder) continue;
                          var fileObj = new File(file, _this2.storage);
                          fileObj.loadMetadata(aes, file); // is it the best way to handle this?

                          fileObj.downloadId = [_this2.downloadId, file.h];
                          filesMap[file.h] = fileObj;
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      var _iterator2 = _createForOfIteratorHelper(nodes),
                          _step2;

                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          var _file = _step2.value;
                          var parent = filesMap[_file.p];

                          if (parent) {
                            var _fileObj = filesMap[_file.h];
                            if (!parent.children) parent.children = [];
                            parent.children.push(_fileObj);
                            _fileObj.parent = parent;
                          }
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }

                      _this2.loadMetadata(aes, folder);

                      if (_this2.key && !_this2.attributes) {
                        return cb(Error('Attributes could not be decrypted with provided key.'));
                      }

                      if (_this2.loadedFile) {
                        var loadedNode = filesMap[_this2.loadedFile];

                        if (typeof loadedNode === 'undefined') {
                          cb(Error('Node (file or folder) not found in folder'));
                        } else {
                          cb(null, loadedNode);
                        }
                      } else {
                        cb(null, _this2);
                      }
                    } else {
                      _this2.size = response.s;

                      _this2.decryptAttributes(response.at);

                      if (_this2.key && !_this2.attributes) {
                        return cb(Error('Attributes could not be decrypted with provided key.'));
                      }

                      cb(null, _this2);
                    }
                  });
                  return this;
                }
              }, {
                key: "download",
                value: function download(options, cb) {
                  if (typeof options === 'function') {
                    cb = options;
                    options = {};
                  }

                  if (!options) options = {};
                  var start = options.start || 0;
                  var apiStart = options.returnCiphertext ? start : start - start % 16;
                  var end = options.end || null;
                  var maxConnections = options.maxConnections || 4;
                  var initialChunkSize = options.initialChunkSize || 128 * 1024;
                  var chunkSizeIncrement = options.chunkSizeIncrement || 128 * 1024;
                  var maxChunkSize = options.maxChunkSize || 1024 * 1024;
                  var ssl = 2;
                  var req = {
                    a: 'g',
                    g: 1,
                    ssl: ssl
                  };

                  if (this.nodeId) {
                    req.n = this.nodeId;
                  } else if (Array.isArray(this.downloadId)) {
                    req._querystring = {
                      n: this.downloadId[0]
                    };
                    req.n = this.downloadId[1];
                  } else {
                    req.p = this.downloadId;
                  }

                  if (this.directory) throw Error("Can't download: folder download isn't supported"); // If options.returnCiphertext is true then the ciphertext is returned.
                  // The result can be decrypted later using mega.decrypt() stream

                  if (!this.key && !options.returnCiphertext) throw Error("Can't download: key isn't defined");
                  var decryptStream = this.key && !options.returnCiphertext ? megaDecrypt(this.key, {
                    start: apiStart,
                    disableVerification: apiStart !== 0 || end !== null
                  }) : new PassThrough();
                  var stream = apiStart === start ? decryptStream : decryptStream.pipe(new streamSkip({
                    skip: start - apiStart
                  }));
                  var cs = this.api || notLoggedApi;
                  var requestModule = options.requestModule || this.api.requestModule;
                  cs.request(req, function (err, response) {
                    if (err) return stream.emit('error', err);

                    if (typeof response.g !== 'string' || response.g.substr(0, 4) !== 'http') {
                      return stream.emit('error', Error('MEGA servers returned an invalid response, maybe caused by rate limit'));
                    }

                    if (!end) end = response.s - 1;
                    if (start > end) return stream.emit('error', Error("You can't download past the end of the file."));

                    function handleMegaErrors(resp) {
                      if (resp.statusCode === 200) return;

                      if (resp.statusCode === 509) {
                        var timeLimit = resp.headers['x-mega-time-left'];
                        var error = Error('Bandwidth limit reached: ' + timeLimit + ' seconds until it resets'); // Export error as a property of the error

                        error.timeLimit = timeLimit;
                        stream.emit('error', error);
                        return;
                      }

                      stream.emit('error', Error('MEGA returned a ' + resp.statusCode + ' status code'));
                    }

                    function handleConnectionErrors(err) {
                      stream.emit('error', Error('Connection error: ' + err.message));
                    }

                    if (maxConnections === 1) {
                      var r = requestModule(response.g + '/' + apiStart + '-' + end);
                      r.on('error', handleConnectionErrors);
                      r.on('response', handleMegaErrors);
                      r.pipe(decryptStream); // Abort stream if required

                      stream.on('close', function () {
                        r.abort();
                      });
                    } else {
                      var combined = combined_stream.create();
                      var currentOffset = apiStart;
                      var chunkSize = initialChunkSize;
                      var stopped = false; // Stop the stream on errors and if required

                      stream.on('error', function () {
                        stopped = true;
                      });
                      stream.on('close', function () {
                        stopped = true;
                      });

                      var getChunk = function getChunk() {
                        if (stopped) return;
                        var currentMax = Math.min(end, currentOffset + chunkSize - 1);
                        if (currentMax < currentOffset) return;
                        var r = requestModule(response.g + '/' + currentOffset + '-' + currentMax);
                        r.on('end', getChunk);
                        r.on('error', handleConnectionErrors);
                        r.on('response', handleMegaErrors);
                        combined.append(r);
                        currentOffset = currentMax + 1;

                        if (chunkSize < maxChunkSize) {
                          chunkSize = chunkSize + chunkSizeIncrement;
                        }
                      }; // Pass errors from the combined stream to the main stream


                      combined.on('error', function (err) {
                        return stream.emit('error', err);
                      });

                      for (var _i = 0; _i < maxConnections; _i++) {
                        getChunk();
                      }

                      combined.pipe(decryptStream);
                    }

                    var i = 0;
                    stream.on('data', function (d) {
                      i += d.length;
                      stream.emit('progress', {
                        bytesLoaded: i,
                        bytesTotal: response.s
                      });
                    });
                  });
                  if (cb) streamToCb(stream, cb);
                  return stream;
                }
              }, {
                key: "link",
                value: function link(options, cb) {
                  if (arguments.length === 1 && typeof options === 'function') {
                    cb = options;
                    options = {
                      noKey: false
                    };
                  }

                  if (typeof options === 'boolean') {
                    options = {
                      noKey: options
                    };
                  }

                  var url$$1 = "https://mega.nz/".concat(this.directory ? 'folder' : 'file', "/").concat(this.downloadId);
                  if (!options.noKey && this.key) url$$1 += "#".concat(e64(this.key));

                  if (!options.noKey && this.loadedFile) {
                    // TODO: check if the loaded file is, in fact, a folder
                    url$$1 += "/file/".concat(this.loadedFile);
                  }

                  cb(null, url$$1);
                }
              }], [{
                key: "fromURL",
                value: function fromURL(opt) {
                  if (_typeof(opt) === 'object') {
                    // todo: warn to use File directly
                    return new File(opt);
                  } // Supported formats:
                  // Old format:
                  // https://mega.nz/#!file_handler
                  // https://mega.nz/#!file_handler!file_key
                  // https://mega.nz/#F!folder_handler
                  // https://mega.nz/#F!folder_handler!folder_key
                  // https://mega.nz/#F!folder_handler!folder_key!file_handler
                  // New format (2020):
                  // https://mega.nz/file/file_handler
                  // https://mega.nz/file/file_handler#file_key
                  // https://mega.nz/folder/folder_handler
                  // https://mega.nz/folder/folder_handler#folder_key
                  // https://mega.nz/folder/folder_handler#folder_key/file/file_handler


                  var url$$1 = urlParse(opt);

                  if (url$$1.hostname !== 'mega.nz' && url$$1.hostname !== 'mega.co.nz') {
                    throw Error('Invalid URL: wrong hostname');
                  }

                  if (!url$$1.hash) throw Error('Invalid URL: no hash');

                  if (url$$1.path.match(/\/(file|folder)\//) !== null) {
                    // new format
                    var split = url$$1.hash.substr(1).split('/file/');
                    var fileHandler = url$$1.path.substring(url$$1.path.lastIndexOf('/') + 1, url$$1.path.length + 1);
                    var fileKey = split[0];
                    if (fileHandler && !fileKey || !fileHandler && fileKey) throw Error('Invalid URL: too few arguments');
                    return new File({
                      downloadId: fileHandler,
                      key: fileKey,
                      directory: url$$1.path.indexOf('/folder/') >= 0,
                      loadedFile: split[1]
                    });
                  } else {
                    // old format
                    var _split = url$$1.hash.split('!');

                    if (_split[0] !== '#' && _split[0] !== '#F') {
                      throw Error('Invalid URL: format not recognized');
                    }

                    if (_split.length <= 1) throw Error('Invalid URL: too few arguments');

                    if (_split.length >= (_split[0] === '#' ? 4 : 5)) {
                      throw Error('Invalid URL: too many arguments');
                    }

                    return new File({
                      downloadId: _split[1],
                      key: _split[2],
                      directory: _split[0] === '#F',
                      loadedFile: _split[3]
                    });
                  }
                }
              }, {
                key: "unpackAttributes",
                value: function unpackAttributes(at) {
                  // read until the first null byte
                  var end = 0;

                  while (end < at.length && at.readUInt8(end)) {
                    end++;
                  }

                  at = at.slice(0, end).toString();
                  if (at.substr(0, 6) !== 'MEGA{"') return;

                  try {
                    return JSON.parse(at.substr(4));
                  } catch (e) {}
                }
              }]);

              return File;
            }(EventEmitter);

            var LABEL_NAMES = ['', 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'grey'];

            var KEY_CACHE = {}; // metadata can be mutated, not the content

            var MutableFile = /*#__PURE__*/function (_File) {
              _inherits(MutableFile, _File);

              var _super = _createSuper(MutableFile);

              function MutableFile(opt, storage) {
                var _this;

                _classCallCheck(this, MutableFile);

                _this = _super.call(this, opt);
                _this.storage = storage;
                _this.api = storage.api;
                _this.nodeId = opt.h;
                _this.timestamp = opt.ts;
                _this.type = opt.t;
                _this.directory = !!_this.type;

                if (opt.k) {
                  var idKeyPairs = opt.k.split('/');
                  var aes = storage.aes;

                  var _iterator = _createForOfIteratorHelper(idKeyPairs),
                      _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var idKeyPair = _step.value;
                      var id = idKeyPair.split(':')[0];

                      if (id === storage.user) {
                        opt.k = idKeyPair;
                        break;
                      }

                      var shareKey = storage.shareKeys[id];

                      if (shareKey) {
                        opt.k = idKeyPair;
                        aes = KEY_CACHE[id];

                        if (!aes) {
                          aes = KEY_CACHE[id] = new AES$1(shareKey);
                        }

                        break;
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  _this.loadMetadata(aes, opt);
                }

                return _this;
              }

              _createClass(MutableFile, [{
                key: "loadAttributes",
                value: function loadAttributes() {
                  throw Error('This is not needed for files loaded from logged in sessions');
                }
              }, {
                key: "mkdir",
                value: function mkdir(opt, cb) {
                  var _this2 = this;

                  if (!this.directory) throw Error("node isn't a directory");

                  if (typeof opt === 'string') {
                    opt = {
                      name: opt
                    };
                  }

                  if (!opt.attributes) opt.attributes = {};
                  if (opt.name) opt.attributes.n = opt.name;

                  if (!opt.attributes.n) {
                    throw Error('file name is required');
                  }

                  if (!opt.target) opt.target = this;
                  if (!opt.key) opt.key = Buffer.from(secureRandom(16));

                  if (opt.key.length !== 16) {
                    throw Error('wrong key length, must be 128bit');
                  }

                  var key = opt.key;
                  var at = MutableFile.packAttributes(opt.attributes);
                  getCipher(key).encryptCBC(at);
                  var storedKey = Buffer.from(key);
                  this.storage.aes.encryptECB(storedKey);
                  var request = {
                    a: 'p',
                    t: opt.target.nodeId ? opt.target.nodeId : opt.target,
                    n: [{
                      h: 'xxxxxxxx',
                      t: 1,
                      a: e64(at),
                      k: e64(storedKey)
                    }]
                  };
                  var shares = getShares(this.storage.shareKeys, this);

                  if (shares.length > 0) {
                    request.cr = makeCryptoRequest(this.storage, [{
                      nodeId: 'xxxxxxxx',
                      key: key
                    }], shares);
                  }

                  this.api.request(request, function (err, response) {
                    if (err) return returnError(err);

                    var file = _this2.storage._importFile(response.f[0]);

                    _this2.storage.emit('add', file);

                    if (cb) {
                      cb(null, file);
                    }
                  });

                  function returnError(e) {
                    if (cb) cb(e);
                  }
                }
              }, {
                key: "upload",
                value: function upload(opt, source, cb) {
                  var _this3 = this;

                  if (!this.directory) throw Error('node is not a directory');

                  if (arguments.length === 2 && typeof source === 'function') {
                    var _ref = [source, null];
                    cb = _ref[0];
                    source = _ref[1];
                  }

                  if (typeof opt === 'string') {
                    opt = {
                      name: opt
                    };
                  }

                  if (!opt.attributes) opt.attributes = {};
                  if (opt.name) opt.attributes.n = opt.name;

                  if (!opt.attributes.n) {
                    throw Error('File name is required.');
                  }

                  if (!opt.target) opt.target = this;
                  var finalKey;
                  var key = formatKey(opt.key);
                  if (!key) key = secureRandom(24);
                  if (!(key instanceof Buffer)) key = Buffer.from(key); // Ciphertext uploading only works if is `uploadCiphertext` is set to true
                  // This is in case some application allowed key to be modified
                  // by the users without checking the size

                  var keySize = opt.uploadCiphertext ? 32 : 24;

                  if (key.length !== keySize) {
                    throw Error('Wrong key length. Key must be 192bit');
                  }

                  if (opt.uploadCiphertext) {
                    finalKey = key;
                    key = unmergeKeyMac(key).slice(0, 24);
                  }

                  opt.key = key;
                  var hashes = [];

                  var checkCallbacks = function checkCallbacks(err, type, hash, encrypter) {
                    if (err) return returnError(err);

                    if (!hash || hash.length === 0) {
                      returnError(Error('Server returned a invalid response while uploading'));
                      return;
                    }

                    var errorCheck = Number(hash.toString());

                    if (errorCheck < 0) {
                      returnError(Error('Server returned error ' + errorCheck + ' while uploading'));
                      return;
                    }

                    hashes[type] = hash;
                    if (type === 0 && !finalKey) finalKey = encrypter.key;
                    if (opt.thumbnailImage && !hashes[1]) return;
                    if (opt.previewImage && !hashes[2]) return;
                    if (!hashes[0]) return;
                    var at = MutableFile.packAttributes(opt.attributes);
                    getCipher(finalKey).encryptCBC(at);
                    var storedKey = Buffer.from(finalKey);

                    _this3.storage.aes.encryptECB(storedKey);

                    var fileObject = {
                      h: e64(hashes[0]),
                      t: 0,
                      a: e64(at),
                      k: e64(storedKey)
                    };

                    if (hashes.length !== 1) {
                      fileObject.fa = hashes.slice(1).map(function (hash, index) {
                        return index + '*' + e64(hash);
                      }).filter(function (e) {
                        return e;
                      }).join('/');
                    }

                    var request = {
                      a: 'p',
                      t: opt.target.nodeId ? opt.target.nodeId : opt.target,
                      n: [fileObject]
                    };
                    var shares = getShares(_this3.storage.shareKeys, _this3);

                    if (shares.length > 0) {
                      request.cr = makeCryptoRequest(_this3.storage, [{
                        nodeId: fileObject.h,
                        key: finalKey
                      }], shares);
                    }

                    _this3.api.request(request, function (err, response) {
                      if (err) return returnError(err);

                      var file = _this3.storage._importFile(response.f[0]);

                      _this3.storage.emit('add', file);

                      stream.emit('complete', file);
                      if (cb) cb(null, file);
                    });
                  };

                  if (opt.thumbnailImage) {
                    this._uploadAttribute(opt, opt.thumbnailImage, 1, checkCallbacks);
                  }

                  if (opt.previewImage) {
                    this._uploadAttribute(opt, opt.previewImage, 2, checkCallbacks);
                  }

                  var stream = this._upload(opt, source, 0, checkCallbacks);

                  var returnError = function returnError(e) {
                    if (cb) {
                      cb(e);
                    } else {
                      stream.emit('error', e);
                    }
                  };

                  return stream;
                }
              }, {
                key: "_upload",
                value: function _upload(opt, source, type, cb) {
                  var _this4 = this;

                  var encrypter = opt.uploadCiphertext ? through_1() : megaEncrypt(opt.key);
                  var pause = through_1().pause();
                  var stream = streamCombiner(pause, encrypter); // Size is needed before upload. Kills the streaming otherwise.

                  var size = opt.size; // handle buffer

                  if (source && typeof source.pipe !== 'function') {
                    size = source.length;
                    stream.end(source);
                  }

                  if (size) {
                    this._uploadWithSize(stream, size, encrypter, pause, type, opt, cb);
                  } else {
                    stream = streamCombiner(detectSize(function (size) {
                      _this4._uploadWithSize(stream, size, encrypter, pause, type, opt, cb);
                    }), stream);
                  } // handle stream


                  if (source && typeof source.pipe === 'function') {
                    source.pipe(stream);
                  }

                  return stream;
                }
              }, {
                key: "_uploadAttribute",
                value: function _uploadAttribute(opt, source, type, cb) {
                  var _this5 = this;

                  var gotBuffer = function gotBuffer(err, buffer) {
                    if (err) return cb(err);
                    var len = buffer.length;
                    var rest = Math.ceil(len / 16) * 16 - len;

                    if (rest !== 0) {
                      buffer = Buffer.concat([buffer, Buffer.alloc(rest)]);
                    }

                    var encrypter = opt.handle ? getCipher(opt.key) : new AES$1(opt.key.slice(0, 16));
                    encrypter.encryptCBC(buffer);
                    var pause = through_1().pause();
                    var stream = streamCombiner(pause);
                    stream.end(buffer);

                    _this5._uploadWithSize(stream, buffer.length, stream, pause, type, opt, cb);
                  }; // handle buffer


                  if (source instanceof Buffer) {
                    gotBuffer(null, source);
                    return;
                  }

                  streamToCb(source, gotBuffer);
                }
              }, {
                key: "_uploadWithSize",
                value: function _uploadWithSize(stream, size, source, pause, type, opt, cb) {
                  var _this6 = this;

                  var ssl = 2;
                  var getUrlRequest = type === 0 ? {
                    a: 'u',
                    ssl: ssl,
                    s: size,
                    ms: 0,
                    r: 0,
                    e: 0,
                    v: 2
                  } : {
                    a: 'ufa',
                    ssl: ssl,
                    s: size
                  };

                  if (opt.handle) {
                    getUrlRequest.h = opt.handle;
                  }

                  var initialChunkSize = type === 0 ? opt.initialChunkSize || 128 * 1024 : size;
                  var chunkSizeIncrement = opt.chunkSizeIncrement || 128 * 1024;
                  var maxChunkSize = opt.maxChunkSize || 1024 * 1024;
                  var maxConnections = opt.maxConnections || 4;
                  var currentChunkSize = initialChunkSize;
                  var activeConnections = 0;
                  var isReading = false;
                  var position = 0;
                  var remainingBuffer;
                  var uploadBuffer, uploadURL;
                  var chunkSize, chunkPos;

                  var handleChunk = function handleChunk() {
                    chunkSize = Math.min(currentChunkSize, size - position);
                    uploadBuffer = Buffer.alloc(chunkSize);
                    activeConnections++;

                    if (currentChunkSize < maxChunkSize) {
                      currentChunkSize += chunkSizeIncrement;
                    }

                    chunkPos = 0;

                    if (remainingBuffer) {
                      remainingBuffer.copy(uploadBuffer);
                      chunkPos = Math.min(remainingBuffer.length, chunkSize);
                      remainingBuffer = remainingBuffer.length > chunkSize ? remainingBuffer.slice(chunkSize) : null;
                    } // It happens when the remaining buffer contains the entire chunk


                    if (chunkPos === chunkSize) {
                      sendChunk();
                    } else {
                      isReading = true;
                      pause.resume();
                    }
                  };

                  var sendChunk = function sendChunk() {
                    var httpreq = _this6.api.requestModule({
                      method: 'POST',
                      body: uploadBuffer,
                      uri: uploadURL + '/' + (type === 0 ? position : type - 1),
                      forever: true
                    });

                    httpreq.on('error', function (error) {
                      stream.emit('error', Error('Connection error: ' + error.message));
                    });
                    httpreq.on('response', function (response) {
                      if (response.statusCode === 200) return;
                      stream.emit('error', Error('MEGA returned a ' + response.statusCode + ' status code'));
                    });
                    uploadBuffer = null;
                    position += chunkSize;
                    streamToCb(httpreq, function (err, hash) {
                      if (err || !hash || hash.length > 0) {
                        source.end();
                        cb(err, type, hash, source);
                      } else if (position < size && !isReading) {
                        handleChunk();
                      }
                    });

                    if (position < size && !isReading && activeConnections < maxConnections) {
                      handleChunk();
                    }
                  };

                  var sizeCheck = 0;
                  source.on('data', function (data) {
                    sizeCheck += data.length;
                    stream.emit('progress', {
                      bytesLoaded: sizeCheck,
                      bytesTotal: size
                    });
                    data.copy(uploadBuffer, chunkPos);
                    chunkPos += data.length;

                    if (chunkPos >= chunkSize) {
                      isReading = false;
                      pause.pause();
                      remainingBuffer = data.slice(data.length - (chunkPos - chunkSize));
                      sendChunk();
                    }
                  });
                  source.on('end', function () {
                    if (size && sizeCheck !== size) {
                      stream.emit('error', Error('Specified data size does not match: ' + size + ' !== ' + sizeCheck));
                    }
                  });
                  this.api.request(getUrlRequest, function (err, resp) {
                    if (err) return cb(err);
                    uploadURL = resp.p;
                    handleChunk();
                  });
                }
              }, {
                key: "uploadAttribute",
                value: function uploadAttribute(type, data, callback) {
                  var _this7 = this;

                  if (typeof type === 'string') {
                    type = ['thumbnail', 'preview'].indexOf(type);
                  }

                  if (type !== 0 && type !== 1) throw Error('Invalid attribute type');

                  this._uploadAttribute({
                    key: this.key,
                    handle: this.nodeId
                  }, data, type + 1, function (err, streamType, hash, encrypter) {
                    if (err) return callback(err);
                    var request = {
                      a: 'pfa',
                      n: _this7.nodeId,
                      fa: type + '*' + e64(hash)
                    };

                    _this7.api.request(request, function (err, response) {
                      if (err) return callback(err);
                      callback(null, _this7);
                    });
                  });
                }
              }, {
                key: "delete",
                value: function _delete(permanent, cb) {
                  if (typeof permanent === 'function') {
                    cb = permanent;
                    permanent = undefined;
                  }

                  if (typeof permanent === 'undefined') {
                    permanent = this.parent === this.storage.trash;
                  }

                  if (permanent) {
                    this.api.request({
                      a: 'd',
                      n: this.nodeId
                    }, cb);
                  } else {
                    this.moveTo(this.storage.trash, cb);
                  }

                  return this;
                }
              }, {
                key: "moveTo",
                value: function moveTo(target, cb) {
                  if (typeof target === 'string') {
                    target = this.storage.files[target];
                  }

                  if (!(target instanceof File)) {
                    throw Error('target must be a folder or a nodeId');
                  }

                  var request = {
                    a: 'm',
                    n: this.nodeId,
                    t: target.nodeId
                  };
                  var shares = getShares(this.storage.shareKeys, target);

                  if (shares.length > 0) {
                    request.cr = makeCryptoRequest(this.storage, [this], shares);
                  }

                  this.api.request(request, cb);
                  return this;
                }
              }, {
                key: "setAttributes",
                value: function setAttributes(attributes, cb) {
                  var _this8 = this;

                  Object.assign(this.attributes, attributes);
                  var newAttributes = MutableFile.packAttributes(this.attributes);
                  getCipher(this.key).encryptCBC(newAttributes);
                  this.api.request({
                    a: 'a',
                    n: this.nodeId,
                    at: e64(newAttributes)
                  }, function () {
                    _this8.parseAttributes(_this8.attributes);

                    if (cb) cb();
                  });
                  return this;
                }
              }, {
                key: "rename",
                value: function rename(filename, cb) {
                  this.setAttributes({
                    n: filename
                  }, cb);
                  return this;
                }
              }, {
                key: "setLabel",
                value: function setLabel(label, cb) {
                  if (typeof label === 'string') label = LABEL_NAMES.indexOf(label);

                  if (typeof label !== 'number' || Math.floor(label) !== label || label < 0 || label > 7) {
                    throw Error('label must be a integer between 0 and 7 or a valid label name');
                  }

                  this.setAttributes({
                    lbl: label
                  }, cb);
                  return this;
                }
              }, {
                key: "setFavorite",
                value: function setFavorite(isFavorite, cb) {
                  this.setAttributes({
                    fav: isFavorite ? 1 : 0
                  }, cb);
                  return this;
                }
              }, {
                key: "link",
                value: function link(options, cb) {
                  var _this9 = this;

                  if (arguments.length === 1 && typeof options === 'function') {
                    cb = options;
                    options = {
                      noKey: false
                    };
                  }

                  if (typeof options === 'boolean') {
                    options = {
                      noKey: options
                    };
                  } // __folderKey is used internally, don't use this


                  var folderKey = options.__folderKey;

                  if (this.directory && !folderKey) {
                    this.shareFolder(options, cb);
                    return this;
                  }

                  this.api.request({
                    a: 'l',
                    n: this.nodeId
                  }, function (err, id) {
                    if (err) return cb(err);
                    var url = "https://mega.nz/".concat(folderKey ? 'folder' : 'file', "/").concat(id);
                    if (!options.noKey && _this9.key) url += "#".concat(e64(folderKey || _this9.key));
                    cb(null, url);
                  });
                  return this;
                }
              }, {
                key: "shareFolder",
                value: function shareFolder(options, cb) {
                  var _this10 = this;

                  if (!this.directory) throw Error("node isn't a folder");
                  var handler = this.nodeId;
                  var storedShareKey = this.storage.shareKeys[handler];

                  if (storedShareKey) {
                    this.link(Object.assign({
                      __folderKey: storedShareKey
                    }, options), cb);
                    return this;
                  }

                  var shareKey = formatKey(options.key);

                  if (!shareKey) {
                    shareKey = secureRandom(16);
                  }

                  if (!(shareKey instanceof Buffer)) {
                    shareKey = Buffer.from(shareKey);
                  }

                  if (shareKey.length !== 16) {
                    nextTick(function () {
                      cb(Error('share key must be 16 byte / 22 characters'));
                    });
                    return;
                  }

                  this.storage.shareKeys[handler] = shareKey;
                  var authKey = Buffer.from(handler + handler);
                  this.storage.aes.encryptECB(authKey);
                  var request = {
                    a: 's2',
                    n: handler,
                    s: [{
                      u: 'EXP',
                      r: 0
                    }],
                    ok: e64(this.storage.aes.encryptECB(Buffer.from(shareKey))),
                    ha: e64(authKey),
                    cr: makeCryptoRequest(this.storage, this)
                  };
                  this.api.request(request, function (err) {
                    if (err) return cb(err);

                    _this10.link(Object.assign({
                      __folderKey: shareKey
                    }, options), cb);
                  });
                  return this;
                }
              }, {
                key: "unshareFolder",
                value: function unshareFolder(options, cb) {
                  var request = {
                    a: 's2',
                    n: this.nodeId,
                    s: [{
                      u: 'EXP',
                      r: ''
                    }]
                  };
                  delete this.storage.shareKeys[this.nodeId];
                  this.api.request(request, function () {
                    if (cb) cb();
                  });
                  return this;
                }
              }, {
                key: "importFile",
                value: function importFile(sharedFile, cb) {
                  var _this11 = this;

                  if (!this.directory) throw Error('importFile can only be called on directories');
                  if (typeof sharedFile === 'string') sharedFile = File.fromURL(sharedFile);
                  if (!(sharedFile instanceof File)) throw Error('First argument of importFile should be a File or a URL string');
                  if (!sharedFile.key) return cb(Error("Can't import files without encryption keys")); // We need file attributes

                  var afterGotAttributes = function afterGotAttributes(err, file) {
                    if (err) return cb(err);
                    var attributes = MutableFile.packAttributes(file.attributes);
                    getCipher(file.key).encryptCBC(attributes);
                    var downloadId = Array.isArray(file.downloadId) ? file.downloadId[1] : file.downloadId;
                    var request = {
                      a: 'p',
                      t: _this11.nodeId,
                      n: [{
                        ph: downloadId,
                        t: 0,
                        a: e64(attributes),
                        k: e64(_this11.storage.aes.encryptECB(file.key))
                      }]
                    };

                    _this11.api.request(request, function (err, response) {
                      if (err) return cb(err);

                      var file = _this11.storage._importFile(response.f[0]);

                      _this11.storage.emit('add', file);

                      if (cb) cb(null, file);
                    });
                  }; // Check if attributes were already downloaded


                  if (sharedFile.attributes) {
                    nextTick(afterGotAttributes, null, sharedFile);
                  } else {
                    sharedFile.loadAttributes(afterGotAttributes);
                  }

                  return this;
                }
              }], [{
                key: "packAttributes",
                value: function packAttributes(attributes) {
                  var at = JSON.stringify(attributes);
                  at = Buffer.from("MEGA".concat(at));
                  var ret = Buffer.alloc(Math.ceil(at.length / 16) * 16);
                  at.copy(ret);
                  return ret;
                }
              }]);

              return MutableFile;
            }(File); // source: https://github.com/meganz/webclient/blob/918222d5e4521c8777b1c8da528f79e0110c1798/js/crypto.js#L3728
            // generate crypto request response for the given nodes/shares matrix


            function makeCryptoRequest(storage, sources, shares) {
              var shareKeys = storage.shareKeys;

              if (!Array.isArray(sources)) {
                sources = selfAndChildren(sources);
              }

              if (!shares) {
                shares = sources.map(function (source) {
                  return getShares(shareKeys, source);
                }).reduce(function (arr, el) {
                  return arr.concat(el);
                }).filter(function (el, index, arr) {
                  return index === arr.indexOf(el);
                });
              }

              var cryptoRequest = [shares, sources.map(function (node) {
                return node.nodeId;
              }), []]; // TODO: optimize - keep track of pre-existing/sent keys, only send new ones

              for (var i = shares.length; i--;) {
                var aes = new AES$1(shareKeys[shares[i]]);

                for (var j = sources.length; j--;) {
                  var fileKey = Buffer.from(sources[j].key);

                  if (fileKey && (fileKey.length === 32 || fileKey.length === 16)) {
                    cryptoRequest[2].push(i, j, e64(aes.encryptECB(fileKey)));
                  }
                }
              }

              return cryptoRequest;
            }

            function selfAndChildren(node) {
              return [node].concat((node.children || []).map(selfAndChildren).reduce(function (arr, el) {
                return arr.concat(el);
              }, []));
            }

            function getShares(shareKeys, node) {
              var handle = node.nodeId;
              var parent = node.parent;
              var shares = [];

              if (shareKeys[handle]) {
                shares.push(handle);
              }

              return parent ? shares.concat(getShares(shareKeys, parent)) : shares;
            }

            var Storage = /*#__PURE__*/function (_EventEmitter) {
              _inherits(Storage, _EventEmitter);

              var _super = _createSuper(Storage);

              function Storage(options, cb) {
                var _this;

                _classCallCheck(this, Storage);

                _this = _super.call(this);

                if (arguments.length === 1 && typeof options === 'function') {
                  cb = options;
                  options = {};
                }

                if (!options.email) {
                  throw Error("starting a session without credentials isn't supported");
                }

                if (!cb) {
                  cb = function cb(err) {
                    // Would be nicer to emit error event?
                    if (err) throw err;
                  };
                } // Defaults


                options.keepalive = options.keepalive === undefined ? true : !!options.keepalive;
                options.autoload = options.autoload === undefined ? true : !!options.autoload;
                options.autologin = options.autologin === undefined ? true : !!options.autologin;
                _this.api = new API(options.keepalive);
                _this.files = {};
                _this.options = options;

                if (options.autologin) {
                  _this.login(cb);
                } else {
                  // Do not release Zalgo!
                  nextTick(function () {
                    return cb(null, _assertThisInitialized(_this));
                  });
                }

                _this.status = 'closed';
                return _this;
              }

              _createClass(Storage, [{
                key: "login",
                value: function login(cb) {
                  var _this2 = this;

                  var ready = function ready() {
                    _this2.status = 'ready';
                    cb(null, _this2);

                    _this2.emit('ready', _this2);
                  };

                  var loadUser = function loadUser(cb) {
                    _this2.api.request({
                      a: 'ug'
                    }, function (err, response) {
                      if (err) return cb(err);
                      _this2.name = response.name;
                      _this2.user = response.u;

                      if (_this2.options.autoload) {
                        _this2.reload(true, function (err) {
                          if (err) return cb(err);
                          ready();
                        });
                      } else {
                        ready();
                      }
                    });
                  }; // MEGA lower cases email addresses (issue #40)


                  this.email = this.options.email.toLowerCase();

                  var handleV1Account = function handleV1Account(cb) {
                    var pw = prepareKey(Buffer.from(_this2.options.password)); // after generating the AES key the password isn't needed anymore

                    delete _this2.options.password;
                    var aes = new AES$1(pw);
                    var uh = e64(aes.stringhash(Buffer.from(_this2.email)));
                    var request = {
                      a: 'us',
                      user: _this2.email,
                      uh: uh
                    };
                    finishLogin(request, aes, cb);
                  };

                  var handleV2Account = function handleV2Account(info, cb) {
                    prepareKeyV2(Buffer.from(_this2.options.password), info, function (err, result) {
                      if (err) return cb(err); // after generating the AES key the password isn't needed anymore

                      delete _this2.options.password;
                      var aes = new AES$1(result.slice(0, 16));
                      var uh = e64(result.slice(16));
                      var request = {
                        a: 'us',
                        user: _this2.email,
                        uh: uh
                      };
                      finishLogin(request, aes, cb);
                    });
                  };

                  var finishLogin = function finishLogin(request, aes, cb) {
                    _this2.api.request(request, function (err, response) {
                      if (err) return cb(err);
                      _this2.key = formatKey(response.k);
                      aes.decryptECB(_this2.key);
                      _this2.aes = new AES$1(_this2.key);
                      var t = formatKey(response.csid);

                      var privk = _this2.aes.decryptECB(formatKey(response.privk));

                      var rsaPrivk = cryptoDecodePrivKey(privk);
                      if (!rsaPrivk) throw Error('invalid credentials');
                      var sid = e64(cryptoRsaDecrypt(t, rsaPrivk).slice(0, 43));
                      _this2.api.sid = _this2.sid = sid;
                      _this2.RSAPrivateKey = rsaPrivk;
                      loadUser(cb);
                    });
                  };

                  this.api.request({
                    a: 'us0',
                    user: this.email
                  }, function (err, response) {
                    if (err) return cb(err);
                    if (response.v === 1) return handleV1Account(cb);
                    if (response.v === 2) return handleV2Account(response, cb);
                    cb(Error('Account version not supported'));
                  });
                  this.status = 'connecting';
                }
              }, {
                key: "reload",
                value: function reload(force, cb) {
                  var _this3 = this;

                  if (typeof force === 'function') {
                    var _ref = [cb, force];
                    force = _ref[0];
                    cb = _ref[1];
                  }

                  if (this.status === 'connecting' && !force) {
                    return this.once('ready', this.reload.bind(this, force, cb));
                  }

                  this.mounts = [];
                  this.api.request({
                    a: 'f',
                    c: 1
                  }, function (err, response) {
                    if (err) return cb(err);
                    _this3.shareKeys = response.ok.reduce(function (shares, share) {
                      var handler = share.h; // MEGA handles share authenticity by checking the value below

                      var auth = _this3.aes.encryptECB(Buffer.from(handler + handler)); // original implementation doesn't compare in constant time, but...


                      if (constantTimeCompare(formatKey(share.ha), auth)) {
                        shares[handler] = _this3.aes.decryptECB(formatKey(share.k));
                      } // If verification fails the share was tampered... by MEGA servers.
                      // Well, never trust the server, the code says...


                      return shares;
                    }, {});
                    response.f.forEach(function (file) {
                      return _this3._importFile(file);
                    });
                    cb(null, _this3.mounts);
                  });
                  this.api.on('sc', function (arr) {
                    var deleted = {};
                    arr.forEach(function (o) {
                      if (o.a === 'u') {
                        var file = _this3.files[o.n];

                        if (file) {
                          file.timestamp = o.ts;
                          file.decryptAttributes(o.at);
                          file.emit('update');

                          _this3.emit('update', file);
                        }
                      } else if (o.a === 'd') {
                        deleted[o.n] = true; // Don't know yet if move or delete.
                      } else if (o.a === 't') {
                        o.t.f.forEach(function (f) {
                          var file = _this3.files[f.h];

                          if (file) {
                            delete deleted[f.h];
                            var oldparent = file.parent;
                            if (oldparent.nodeId === f.p) return; // todo: move to setParent() to avoid duplicate.

                            oldparent.children.splice(oldparent.children.indexOf(file), 1);
                            file.parent = _this3.files[f.p];
                            if (!file.parent.children) file.parent.children = [];
                            file.parent.children.push(file);
                            file.emit('move', oldparent);

                            _this3.emit('move', file, oldparent);
                          } else {
                            _this3.emit('add', _this3._importFile(f));
                          }
                        });
                      }
                    });
                    Object.keys(deleted).forEach(function (n) {
                      var file = _this3.files[n];
                      var parent = file.parent;
                      parent.children.splice(parent.children.indexOf(file), 1);

                      _this3.emit('delete', file);

                      file.emit('delete');
                    });
                  });
                }
              }, {
                key: "_importFile",
                value: function _importFile(f) {
                  // todo: no support for updates
                  if (!this.files[f.h]) {
                    var file = this.files[f.h] = new MutableFile(f, this);

                    if (f.t === NODE_TYPE_DRIVE) {
                      this.root = file;
                      file.name = 'Cloud Drive';
                    }

                    if (f.t === NODE_TYPE_RUBBISH_BIN) {
                      this.trash = file;
                      file.name = 'Rubbish Bin';
                    }

                    if (f.t === NODE_TYPE_INBOX) {
                      this.inbox = file;
                      file.name = 'Inbox';
                    }

                    if (f.t > 1) {
                      this.mounts.push(file);
                    }

                    if (f.p) {
                      var parent = this.files[f.p]; // Issue 58: some accounts have orphan files

                      if (parent) {
                        if (!parent.children) parent.children = [];
                        parent.children.push(file);
                        file.parent = parent;
                      }
                    }
                  }

                  return this.files[f.h];
                } // alternative to this.root.mkdir

              }, {
                key: "mkdir",
                value: function mkdir(opt, cb) {
                  var _this4 = this;

                  // Wait for ready event.
                  if (this.status !== 'ready') {
                    this.on('ready', function () {
                      return _this4.root.mkdir(opt, cb);
                    });
                    return;
                  }

                  return this.root.mkdir(opt, cb);
                } // alternative to this.root.upload

              }, {
                key: "upload",
                value: function upload(opt, buffer, cb) {
                  var _this5 = this;

                  // Wait for ready event.
                  if (this.status !== 'ready') {
                    this.on('ready', function () {
                      return _this5.root.upload(opt, buffer, cb);
                    });
                    return;
                  }

                  return this.root.upload(opt, buffer, cb);
                }
              }, {
                key: "close",
                value: function close() {
                  // does not handle still connecting or incomplete streams
                  this.status = 'closed';
                  this.api.close();
                }
              }, {
                key: "getAccountInfo",
                value: function getAccountInfo(cb) {
                  this.api.request({
                    a: 'uq',
                    strg: 1,
                    xfer: 1,
                    pro: 1
                  }, function (err, response) {
                    if (err) cb(err);
                    var account = {}; // Normalize responses from API

                    account.type = response.utype;
                    account.spaceUsed = response.cstrg;
                    account.spaceTotal = response.mstrg;
                    account.downloadBandwidthTotal = response.mxfer || Math.pow(1024, 5) * 10;
                    account.downloadBandwidthUsed = response.caxfer || 0;
                    account.sharedBandwidthUsed = response.csxfer || 0;
                    account.sharedBandwidthLimit = response.srvratio;
                    cb(null, account);
                  });
                }
              }, {
                key: "toJSON",
                value: function toJSON() {
                  return {
                    key: e64(this.key),
                    sid: this.sid,
                    name: this.name,
                    user: this.user,
                    options: this.options
                  };
                }
              }], [{
                key: "fromJSON",
                value: function fromJSON(json) {
                  var storage = new Storage(Object.assign(json.options, {
                    autoload: false,
                    autologin: false
                  }));
                  storage.key = d64(json.key);
                  storage.aes = new AES$1(storage.key);
                  storage.api.sid = storage.sid = json.sid;
                  storage.name = json.name;
                  storage.user = json.user;
                  return storage;
                }
              }]);

              return Storage;
            }(EventEmitter);

            var NODE_TYPE_DRIVE = 2;
            var NODE_TYPE_INBOX = 3;
            var NODE_TYPE_RUBBISH_BIN = 4;

            // File and Storage directly as built sizes will be smaller

            function mega(options, cb) {
              return new Storage(options, cb);
            }

            mega.Storage = Storage;
            mega.File = File;
            mega.file = File.fromURL;
            mega.encrypt = megaEncrypt;
            mega.decrypt = megaDecrypt;

            return mega;

})));
